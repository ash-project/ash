# SPDX-FileCopyrightText: 2019 ash contributors <https://github.com/ash-project/ash/graphs/contributors>
#
# SPDX-License-Identifier: MIT

defmodule GenerateIgniterErrorTest do
  @moduledoc """
  Generates test/ash/igniter_error_test.exs for Ash.Igniter error handling.
  Invoked via mix generate_igniter_error_test (Mix task in lib delegates here).
  """
  @test_file_path "test/ash/igniter_error_test.exs"
  @max_message_length 200

  def run(_args) do
    igniter_path = "lib/ash/igniter.ex"

    unless File.exists?(igniter_path) do
      Mix.shell().error("Error: #{igniter_path} not found")
      exit({:shutdown, 1})
    end

    igniter_code = File.read!(igniter_path)

    error_logs = extract_error_logs(igniter_code)
    error_wrappers = extract_error_wrappers(igniter_code)

    test_content = generate_test_file(igniter_code, error_logs, error_wrappers)

    File.write!(@test_file_path, test_content)

    Mix.shell().info("Generated test file: #{@test_file_path}")
    Mix.shell().info("Found #{length(error_logs)} error logging locations")
    Mix.shell().info("Found #{length(error_wrappers)} error wrapper functions")
    Mix.shell().info("Run tests with: mix test #{@test_file_path}")
  end

  defp extract_error_logs(code) do
    code
    |> String.split("\n")
    |> Enum.with_index(1)
    |> Enum.reduce([], fn {line, line_num}, acc ->
      cond do
        String.contains?(line, "Logger.error") ->
          message = extract_log_message(line)
          [{:error, line_num, message} | acc]

        String.contains?(line, "Logger.warning") ->
          message = extract_log_message(line)
          [{:warning, line_num, message} | acc]

        true ->
          acc
      end
    end)
    |> Enum.reverse()
  end

  defp extract_log_message(line) do
    case Regex.run(~r/Logger\.(error|warning)\("([^"]+)"/, line) do
      [_, _, message] -> message
      _ ->
        # Try alternative pattern for multi-line messages
        case Regex.run(~r/Logger\.(error|warning)\(([^,]+)/, line) do
          [_, _, message] -> String.trim(message, ~s("))
          _ -> "Unknown message"
        end
    end
  end

  defp extract_error_wrappers(code) do
    code
    |> String.split("\n")
    |> Enum.with_index(1)
    |> Enum.reduce([], fn {line, line_num}, acc ->
      if String.match?(line, ~r/defp with_safe_\w+/) do
        case Regex.run(~r/defp (with_safe_\w+)/, line) do
          [_, func_name] -> [{func_name, line_num} | acc]
          _ -> acc
        end
      else
        acc
      end
    end)
    |> Enum.reverse()
  end

  defp generate_test_file(igniter_code, error_logs, error_wrappers) do
    error_log_tests = generate_error_log_tests(error_logs, igniter_code)
    wrapper_tests = generate_wrapper_tests(error_wrappers, igniter_code)
    quality_tests = generate_quality_tests(error_logs, error_wrappers)

    """
    # SPDX-FileCopyrightText: 2019 ash contributors <https://github.com/ash-project/ash/graphs/contributors>
    #
    # SPDX-License-Identifier: MIT
    #
    # Generated by: mix generate_igniter_error_test
    # Generator: test/support/generate_igniter_error_test.ex
    # Verifies that all error logging creates concise messages and all error wrappers function correctly.

    defmodule Ash.Igniter.ErrorTest do
      @moduledoc false
      use ExUnit.Case, async: true

      import ExUnit.CaptureLog

      alias Ash.Igniter

      # Mock structures for testing
      defmodule MockRewrite do
        defstruct [:sources]
      end

      defmodule MockSource do
        defstruct [:filetype]
      end

      defmodule MockExSource do
        defstruct []
      end

      defmodule MockIgniter do
        defstruct [:rewrite, :tasks]
      end

      # Test constants
      @max_message_length #{@max_message_length}

      #{error_log_tests}

      #{wrapper_tests}

      #{quality_tests}
    end
    """
  end

  defp generate_error_log_tests(error_logs, igniter_code) do
    tests =
      error_logs
      |> Enum.map(fn {level, line_num, message} ->
        generate_single_error_log_test(level, line_num, message, igniter_code)
      end)
      |> Enum.join("\n\n")

    """
    describe "Error logging - Message conciseness" do
      #{tests}
    end
    """
  end

  defp generate_single_error_log_test(:error, line_num, message, _igniter_code) do
    test_name = sanitize_test_name("logs concise error message: #{message}")
    message_str = inspect(message)

    """
      test "#{test_name} (line #{line_num})" do
        # Verify error message exists in code
        igniter_code = File.read!("lib/ash/igniter.ex")
        assert igniter_code =~ #{message_str},
          "Error message '#{message}' not found in igniter.ex at line #{line_num}"

        # Verify message is concise (not excessively long)
        assert String.length(#{message_str}) <= @max_message_length,
          "Error message '#{message}' exceeds maximum length of #{@max_message_length} characters"

        # Verify message doesn't contain stack traces or excessive detail
        refute String.contains?(#{message_str}, "Stack trace"),
          "Error message should not contain stack trace text"
        refute String.contains?(#{message_str}, "backtrace"),
          "Error message should not contain backtrace text"
      end
    """
  end

  defp generate_single_error_log_test(:warning, line_num, message, _igniter_code) do
    test_name = sanitize_test_name("logs concise warning message: #{message}")
    message_str = inspect(message)

    """
      test "#{test_name} (line #{line_num})" do
        # Verify warning message exists in code
        igniter_code = File.read!("lib/ash/igniter.ex")
        assert igniter_code =~ #{message_str},
          "Warning message '#{message}' not found in igniter.ex at line #{line_num}"

        # Verify message is concise
        assert String.length(#{message_str}) <= @max_message_length,
          "Warning message '#{message}' exceeds maximum length of #{@max_message_length} characters"
      end
    """
  end

  defp generate_wrapper_tests(error_wrappers, igniter_code) do
    tests =
      error_wrappers
      |> Enum.map(fn {func_name, line_num} ->
        generate_single_wrapper_test(func_name, line_num, igniter_code)
      end)
      |> Enum.join("\n\n")

    """
    describe "Error wrappers - Functionality verification" do
      #{tests}
    end
    """
  end

  defp generate_single_wrapper_test("with_safe_rewrite_access", _line_num, _igniter_code) do
    """
      test "with_safe_rewrite_access handles successful execution" do
        igniter = %MockIgniter{
          rewrite: %MockRewrite{sources: %{test: %MockSource{filetype: %MockExSource{}}}}
        }

        fun = fn rewrite ->
          assert %MockRewrite{} = rewrite
          :success_result
        end

        # Note: This test requires access to private function
        # In practice, test via public API (find_all_matching_modules)
        # or use :erlang.apply if needed for direct testing
        ExUnit.skip("Direct testing requires :erlang.apply or public API wrapper")
      end

      test "with_safe_rewrite_access handles nil rewrite" do
        igniter = %MockIgniter{rewrite: nil}

        # Test via public API
        result = Igniter.find_all_matching_modules(igniter, fn _, _ -> true end)
        assert result == []
      end

      test "with_safe_rewrite_access handles invalid structure" do
        igniter = %{invalid: :structure}

        # Test via public API
        result = Igniter.find_all_matching_modules(igniter, fn _, _ -> true end)
        assert result == []
      end

      test "with_safe_rewrite_access error tuple format" do
        # Verify error tuple format in code
        igniter_code = File.read!("lib/ash/igniter.ex")
        assert igniter_code =~ "{:error, {:rewrite_access_error",
          "Expected error tuple format {:error, {:rewrite_access_error, _}}"
        assert igniter_code =~ "{:error, {:nil_rewrite",
          "Expected error tuple format {:error, {:nil_rewrite, _}}"
        assert igniter_code =~ "{:error, {:invalid_structure",
          "Expected error tuple format {:error, {:invalid_structure, _}}"
      end
    """
  end

  defp generate_single_wrapper_test("with_safe_igniter_update", _line_num, _igniter_code) do
    """
      test "with_safe_igniter_update error tuple format" do
        # Verify error tuple format in code
        igniter_code = File.read!("lib/ash/igniter.ex")
        assert igniter_code =~ "{:error, {:igniter_update_error",
          "Expected error tuple format {:error, {:igniter_update_error, _}}"
      end

      test "with_safe_igniter_update handles errors gracefully" do
        # Test via public API with scan_all option
        igniter = %MockIgniter{rewrite: nil}

        result = Igniter.find_all_matching_modules(igniter, fn _, _ -> true end, scan_all: true)
        assert result == []
      end
    """
  end

  defp generate_single_wrapper_test("with_safe_source_processing", _line_num, _igniter_code) do
    """
      test "with_safe_source_processing error tuple format" do
        # Verify error tuple format in code
        igniter_code = File.read!("lib/ash/igniter.ex")
        assert igniter_code =~ "{:error, []}",
          "Expected error tuple format {:error, []} for source processing errors"
      end

      test "with_safe_source_processing handles nil quoted" do
        # Verify warning is logged for nil quoted
        igniter_code = File.read!("lib/ash/igniter.ex")
        assert igniter_code =~ "Rewrite.Source.get(:quoted) returned nil",
          "Expected warning for nil quoted value"
      end
    """
  end

  defp generate_single_wrapper_test("with_safe_module_extraction", _line_num, _igniter_code) do
    """
      test "with_safe_module_extraction handles errors gracefully" do
        # Verify warning is logged for move_to_nth_argument errors
        igniter_code = File.read!("lib/ash/igniter.ex")
        assert igniter_code =~ "Error moving to nth argument",
          "Expected warning for move_to_nth_argument errors"

        # Verify it continues traversal (doesn't crash)
        assert igniter_code =~ "{zipper, acc}",
          "Expected to continue traversal on error"
      end
    """
  end

  defp generate_single_wrapper_test(func_name, line_num, _igniter_code) do
    """
      test "#{func_name} exists and has error handling (line #{line_num})" do
        igniter_code = File.read!("lib/ash/igniter.ex")
        assert igniter_code =~ "defp #{func_name}",
          "Expected function #{func_name} to exist"
      end
    """
  end

  defp generate_quality_tests(_error_logs, error_wrappers) do
    wrapper_func_names = Enum.map(error_wrappers, &elem(&1, 0)) |> inspect()

    # So generated file contains literal #{func_name} for runtime interpolation
    regex_line = "      pattern = ~r/defp " <> "\#" <> "{" <> "func_name" <> "}" <> "[^{]*\\{[^}]*\\}/s"

    """
    describe "Error message quality checks" do
      test "all error messages contain essential context" do
        igniter_code = File.read!("lib/ash/igniter.ex")

        # Verify all error messages are present
        expected_messages = [
          "Error accessing rewrite.sources",
          "igniter.rewrite is nil",
          "Invalid igniter structure",
          "Error updating igniter with include_all_elixir_files",
          "Error processing source",
          "Rewrite.Source.get(:quoted) returned nil",
          "Error moving to nth argument",
          "Task.async_stream error"
        ]

        Enum.each(expected_messages, fn message ->
          assert igniter_code =~ message,
            "Expected error message '\#{message}' not found in igniter.ex"
        end)
      end

      test "error messages are concise (not excessively verbose)" do
        igniter_code = File.read!("lib/ash/igniter.ex")

        # Extract all Logger.error and Logger.warning calls
        error_calls =
          igniter_code
          |> String.split("\\n")
          |> Enum.filter(fn line ->
            String.contains?(line, "Logger.error") or String.contains?(line, "Logger.warning")
          end)

        Enum.each(error_calls, fn call ->
          # Verify messages don't contain stack traces
          refute String.contains?(call, "Stack trace"),
            "Error message should not contain stack trace: \#{String.slice(call, 0..100)}"
          refute String.contains?(call, "backtrace"),
            "Error message should not contain backtrace: \#{String.slice(call, 0..100)}"

          # Extract message and verify length
          case Regex.run(~r/Logger\\.(error|warning)\\("([^"]+)"/, call) do
            [_, _, message] ->
              assert String.length(message) <= @max_message_length,
                "Error message '\#{message}' exceeds maximum length of \#{@max_message_length} characters"
            _ ->
              :ok
          end
        end)
      end

      test "error wrappers preserve error context in tuples" do
        igniter_code = File.read!("lib/ash/igniter.ex")

        # Verify all error wrappers return proper error tuple format
        expected_error_tuples = [
          "{:error, {:rewrite_access_error",
          "{:error, {:nil_rewrite",
          "{:error, {:invalid_structure",
          "{:error, {:igniter_update_error"
        ]

        Enum.each(expected_error_tuples, fn tuple_pattern ->
          assert igniter_code =~ tuple_pattern,
            "Expected error tuple pattern '\#{tuple_pattern}' not found in igniter.ex"
        end)
      end

      test "all error wrappers have rescue and catch blocks" do
        igniter_code = File.read!("lib/ash/igniter.ex")

        # Verify error wrappers have proper error handling
        wrapper_functions = #{wrapper_func_names}

        Enum.each(wrapper_functions, fn func_name ->
          func_code = extract_function_code(igniter_code, func_name)

          assert func_code =~ "rescue" or func_code =~ "catch",
            "Expected function \#{func_name} to have rescue or catch block"
        end)
      end

      test "Logger calls include file and line metadata" do
        igniter_code = File.read!("lib/ash/igniter.ex")

        # Count Logger.error and Logger.warning calls
        logger_calls =
          igniter_code
          |> String.split("\\n")
          |> Enum.filter(fn line ->
            String.contains?(line, "Logger.error") or String.contains?(line, "Logger.warning")
          end)

        # Verify most Logger calls include file/line metadata
        # (Some may not if they're in different contexts)
        calls_with_metadata =
          Enum.count(logger_calls, fn call ->
            String.contains?(call, "file:") or String.contains?(call, "__ENV__")
          end)

        assert calls_with_metadata > 0,
          "Expected at least some Logger calls to include file/line metadata"
      end
    end

    describe "Integration tests" do
      test "find_all_matching_modules handles errors gracefully" do
        igniter = %MockIgniter{rewrite: nil}

        result = Igniter.find_all_matching_modules(igniter, fn _, _ -> true end)
        assert result == []
      end

      test "find_all_matching_modules with scan_all handles errors gracefully" do
        igniter = %MockIgniter{rewrite: nil}

        result = Igniter.find_all_matching_modules(igniter, fn _, _ -> true end, scan_all: true)
        assert result == []
      end
    end

    defp extract_function_code(code, func_name) do
#{regex_line}
      case Regex.run(pattern, code) do
        [match | _] -> match
        _ -> ""
      end
    end
    """
  end

  defp sanitize_test_name(name) do
    name
    |> String.replace(~r/[^a-zA-Z0-9\s]/, "")
    |> String.replace(~r/\s+/, "_")
    |> String.slice(0, 80)
  end
end
