# SPDX-FileCopyrightText: 2019 ash contributors <https://github.com/ash-project/ash/graphs/contributors>
#
# SPDX-License-Identifier: MIT
#
# Generated by: mix generate_igniter_error_test
# Generator: test/support/generate_igniter_error_test.ex
# Verifies that all error logging creates concise messages and all error wrappers function correctly.

defmodule Ash.Igniter.ErrorTest do
  @moduledoc false
  use ExUnit.Case, async: true

  alias Ash.Igniter

  # Mock structures for testing
  defmodule MockRewrite do
    defstruct [:sources]
  end

  defmodule MockSource do
    defstruct [:filetype]
  end

  defmodule MockExSource do
    defstruct []
  end

  defmodule MockIgniter do
    defstruct [:rewrite, :tasks]
  end

  # Test constants
  @max_message_length 200

  describe "Error logging - Message conciseness" do
    test "logs_concise_error_message_Error_accessing_rewritesources (line 97)" do
    # Verify error message exists in code
    igniter_code = File.read!("lib/ash/igniter.ex")
    assert igniter_code =~ "Error accessing rewrite.sources",
      "Error message 'Error accessing rewrite.sources' not found in igniter.ex at line 97"

    # Verify message is concise (not excessively long)
    assert String.length("Error accessing rewrite.sources") <= @max_message_length,
      "Error message 'Error accessing rewrite.sources' exceeds maximum length of 200 characters"

    # Verify message doesn't contain stack traces or excessive detail
    refute String.contains?("Error accessing rewrite.sources", "Stack trace"),
      "Error message should not contain stack trace text"
    refute String.contains?("Error accessing rewrite.sources", "backtrace"),
      "Error message should not contain backtrace text"
  end


  test "logs_concise_error_message_igniterrewrite_is_nil (line 107)" do
    # Verify error message exists in code
    igniter_code = File.read!("lib/ash/igniter.ex")
    assert igniter_code =~ "igniter.rewrite is nil",
      "Error message 'igniter.rewrite is nil' not found in igniter.ex at line 107"

    # Verify message is concise (not excessively long)
    assert String.length("igniter.rewrite is nil") <= @max_message_length,
      "Error message 'igniter.rewrite is nil' exceeds maximum length of 200 characters"

    # Verify message doesn't contain stack traces or excessive detail
    refute String.contains?("igniter.rewrite is nil", "Stack trace"),
      "Error message should not contain stack trace text"
    refute String.contains?("igniter.rewrite is nil", "backtrace"),
      "Error message should not contain backtrace text"
  end


  test "logs_concise_error_message_Invalid_igniter_structure (line 115)" do
    # Verify error message exists in code
    igniter_code = File.read!("lib/ash/igniter.ex")
    assert igniter_code =~ "Invalid igniter structure",
      "Error message 'Invalid igniter structure' not found in igniter.ex at line 115"

    # Verify message is concise (not excessively long)
    assert String.length("Invalid igniter structure") <= @max_message_length,
      "Error message 'Invalid igniter structure' exceeds maximum length of 200 characters"

    # Verify message doesn't contain stack traces or excessive detail
    refute String.contains?("Invalid igniter structure", "Stack trace"),
      "Error message should not contain stack trace text"
    refute String.contains?("Invalid igniter structure", "backtrace"),
      "Error message should not contain backtrace text"
  end


  test "logs_concise_error_message_Error_updating_igniter_with_includeallelixirfiles (line 131)" do
    # Verify error message exists in code
    igniter_code = File.read!("lib/ash/igniter.ex")
    assert igniter_code =~ "Error updating igniter with include_all_elixir_files",
      "Error message 'Error updating igniter with include_all_elixir_files' not found in igniter.ex at line 131"

    # Verify message is concise (not excessively long)
    assert String.length("Error updating igniter with include_all_elixir_files") <= @max_message_length,
      "Error message 'Error updating igniter with include_all_elixir_files' exceeds maximum length of 200 characters"

    # Verify message doesn't contain stack traces or excessive detail
    refute String.contains?("Error updating igniter with include_all_elixir_files", "Stack trace"),
      "Error message should not contain stack trace text"
    refute String.contains?("Error updating igniter with include_all_elixir_files", "backtrace"),
      "Error message should not contain backtrace text"
  end


  test "logs_concise_warning_message_Error_processing_source (line 153)" do
    # Verify warning message exists in code
    igniter_code = File.read!("lib/ash/igniter.ex")
    assert igniter_code =~ "Error processing source",
      "Warning message 'Error processing source' not found in igniter.ex at line 153"

    # Verify message is concise
    assert String.length("Error processing source") <= @max_message_length,
      "Warning message 'Error processing source' exceeds maximum length of 200 characters"
  end


  test "logs_concise_error_message_Taskasyncstream_error (line 162)" do
    # Verify error message exists in code
    igniter_code = File.read!("lib/ash/igniter.ex")
    assert igniter_code =~ "Task.async_stream error",
      "Error message 'Task.async_stream error' not found in igniter.ex at line 162"

    # Verify message is concise (not excessively long)
    assert String.length("Task.async_stream error") <= @max_message_length,
      "Error message 'Task.async_stream error' exceeds maximum length of 200 characters"

    # Verify message doesn't contain stack traces or excessive detail
    refute String.contains?("Task.async_stream error", "Stack trace"),
      "Error message should not contain stack trace text"
    refute String.contains?("Task.async_stream error", "backtrace"),
      "Error message should not contain backtrace text"
  end


  test "logs_concise_warning_message_RewriteSourcegetquoted_returned_nil (line 179)" do
    # Verify warning message exists in code
    igniter_code = File.read!("lib/ash/igniter.ex")
    assert igniter_code =~ "Rewrite.Source.get(:quoted) returned nil",
      "Warning message 'Rewrite.Source.get(:quoted) returned nil' not found in igniter.ex at line 179"

    # Verify message is concise
    assert String.length("Rewrite.Source.get(:quoted) returned nil") <= @max_message_length,
      "Warning message 'Rewrite.Source.get(:quoted) returned nil' exceeds maximum length of 200 characters"
  end


  test "logs_concise_error_message_Error_processing_source (line 205)" do
    # Verify error message exists in code
    igniter_code = File.read!("lib/ash/igniter.ex")
    assert igniter_code =~ "Error processing source",
      "Error message 'Error processing source' not found in igniter.ex at line 205"

    # Verify message is concise (not excessively long)
    assert String.length("Error processing source") <= @max_message_length,
      "Error message 'Error processing source' exceeds maximum length of 200 characters"

    # Verify message doesn't contain stack traces or excessive detail
    refute String.contains?("Error processing source", "Stack trace"),
      "Error message should not contain stack trace text"
    refute String.contains?("Error processing source", "backtrace"),
      "Error message should not contain backtrace text"
  end


  test "logs_concise_warning_message_Error_moving_to_nth_argument (line 235)" do
    # Verify warning message exists in code
    igniter_code = File.read!("lib/ash/igniter.ex")
    assert igniter_code =~ "Error moving to nth argument",
      "Warning message 'Error moving to nth argument' not found in igniter.ex at line 235"

    # Verify message is concise
    assert String.length("Error moving to nth argument") <= @max_message_length,
      "Warning message 'Error moving to nth argument' exceeds maximum length of 200 characters"
  end

end


  describe "Error wrappers - Functionality verification" do
    @tag :skip
  test "with_safe_rewrite_access handles successful execution" do
    # Note: This test requires access to private function
    # In practice, test via public API (find_all_matching_modules)
    # or use :erlang.apply if needed for direct testing
    # Direct testing requires :erlang.apply or public API wrapper
  end

  test "with_safe_rewrite_access handles nil rewrite" do
    igniter = %MockIgniter{rewrite: nil}

    # Test via public API
    result = Igniter.find_all_matching_modules(igniter, fn _, _ -> true end)
    assert result == []
  end

  test "with_safe_rewrite_access handles invalid structure" do
    igniter = %{invalid: :structure}

    # Test via public API
    result = Igniter.find_all_matching_modules(igniter, fn _, _ -> true end)
    assert result == []
  end

  test "with_safe_rewrite_access error tuple format" do
    # Verify error tuple format in code
    igniter_code = File.read!("lib/ash/igniter.ex")
    assert igniter_code =~ "{:error, {:rewrite_access_error",
      "Expected error tuple format {:error, {:rewrite_access_error, _}}"
    assert igniter_code =~ "{:error, {:nil_rewrite",
      "Expected error tuple format {:error, {:nil_rewrite, _}}"
    assert igniter_code =~ "{:error, {:invalid_structure",
      "Expected error tuple format {:error, {:invalid_structure, _}}"
  end


  test "with_safe_igniter_update error tuple format" do
    # Verify error tuple format in code
    igniter_code = File.read!("lib/ash/igniter.ex")
    assert igniter_code =~ "{:error, {:igniter_update_error",
      "Expected error tuple format {:error, {:igniter_update_error, _}}"
  end

  test "with_safe_igniter_update handles errors gracefully" do
    # Test via public API with scan_all option
    igniter = %MockIgniter{rewrite: nil}

    result = Igniter.find_all_matching_modules(igniter, fn _, _ -> true end, scan_all: true)
    assert result == []
  end


  test "with_safe_source_processing error tuple format" do
    # Verify error tuple format in code
    igniter_code = File.read!("lib/ash/igniter.ex")
    assert igniter_code =~ "{:error, []}",
      "Expected error tuple format {:error, []} for source processing errors"
  end

  test "with_safe_source_processing handles nil quoted" do
    # Verify warning is logged for nil quoted
    igniter_code = File.read!("lib/ash/igniter.ex")
    assert igniter_code =~ "Rewrite.Source.get(:quoted) returned nil",
      "Expected warning for nil quoted value"
  end


  test "with_safe_module_extraction handles errors gracefully" do
    # Verify warning is logged for move_to_nth_argument errors
    igniter_code = File.read!("lib/ash/igniter.ex")
    assert igniter_code =~ "Error moving to nth argument",
      "Expected warning for move_to_nth_argument errors"

    # Verify it continues traversal (doesn't crash)
    assert igniter_code =~ "{zipper, acc}",
      "Expected to continue traversal on error"
  end

end


  describe "Error message quality checks" do
  test "all error messages contain essential context" do
    igniter_code = File.read!("lib/ash/igniter.ex")

    # Verify all error messages are present
    expected_messages = [
      "Error accessing rewrite.sources",
      "igniter.rewrite is nil",
      "Invalid igniter structure",
      "Error updating igniter with include_all_elixir_files",
      "Error processing source",
      "Rewrite.Source.get(:quoted) returned nil",
      "Error moving to nth argument",
      "Task.async_stream error"
    ]

    Enum.each(expected_messages, fn message ->
      assert igniter_code =~ message,
        "Expected error message '#{message}' not found in igniter.ex"
    end)
  end

  test "error messages are concise (not excessively verbose)" do
    igniter_code = File.read!("lib/ash/igniter.ex")

    # Extract all Logger.error and Logger.warning calls
    error_calls =
      igniter_code
      |> String.split("\n")
      |> Enum.filter(fn line ->
        String.contains?(line, "Logger.error") or String.contains?(line, "Logger.warning")
      end)

    Enum.each(error_calls, fn call ->
      # Verify messages don't contain stack traces
      refute String.contains?(call, "Stack trace"),
        "Error message should not contain stack trace: #{String.slice(call, 0..100)}"
      refute String.contains?(call, "backtrace"),
        "Error message should not contain backtrace: #{String.slice(call, 0..100)}"

      # Extract message and verify length
      case Regex.run(~r/Logger\.(error|warning)\("([^"]+)"/, call) do
        [_, _, message] ->
          assert String.length(message) <= @max_message_length,
            "Error message '#{message}' exceeds maximum length of #{@max_message_length} characters"
        _ ->
          :ok
      end
    end)
  end

  test "error wrappers preserve error context in tuples" do
    igniter_code = File.read!("lib/ash/igniter.ex")

    # Verify all error wrappers return proper error tuple format
    expected_error_tuples = [
      "{:error, {:rewrite_access_error",
      "{:error, {:nil_rewrite",
      "{:error, {:invalid_structure",
      "{:error, {:igniter_update_error"
    ]

    Enum.each(expected_error_tuples, fn tuple_pattern ->
      assert igniter_code =~ tuple_pattern,
        "Expected error tuple pattern '#{tuple_pattern}' not found in igniter.ex"
    end)
  end

  test "all error wrappers have rescue and catch blocks" do
    igniter_code = File.read!("lib/ash/igniter.ex")

    # Verify error wrappers have proper error handling
    # with_safe_module_extraction uses pattern matching (case/with) instead of rescue/catch
    wrapper_functions_with_rescue = ["with_safe_rewrite_access", "with_safe_igniter_update", "with_safe_source_processing"]
    wrapper_functions_with_pattern_matching = ["with_safe_module_extraction"]

    Enum.each(wrapper_functions_with_rescue, fn func_name ->
      func_code = extract_function_code(igniter_code, func_name)

      assert func_code =~ "rescue" or func_code =~ "catch",
        "Expected function #{func_name} to have rescue or catch block"
    end)

    Enum.each(wrapper_functions_with_pattern_matching, fn func_name ->
      func_code = extract_function_code(igniter_code, func_name)

      # Verify it has proper error handling via pattern matching
      assert func_code =~ "case" or func_code =~ "with" or func_code =~ ":error",
        "Expected function #{func_name} to have error handling via pattern matching"
    end)
  end

  test "Logger calls include file and line metadata" do
    igniter_code = File.read!("lib/ash/igniter.ex")

    # Find all Logger.error and Logger.warning calls with their context
    # Logger calls span multiple lines, so we need to check surrounding lines
    lines = String.split(igniter_code, "\n")
    
    calls_with_metadata =
      lines
      |> Enum.with_index()
      |> Enum.filter(fn {line, _idx} ->
        String.contains?(line, "Logger.error") or String.contains?(line, "Logger.warning")
      end)
      |> Enum.count(fn {_line, idx} ->
        # Check the Logger call line and up to 5 lines after it for metadata
        context_lines = Enum.slice(lines, idx, 6) |> Enum.join("\n")
        String.contains?(context_lines, "file:") or String.contains?(context_lines, "__ENV__")
      end)

    assert calls_with_metadata > 0,
      "Expected at least some Logger calls to include file/line metadata"
  end
end

describe "Integration tests" do
  test "find_all_matching_modules handles errors gracefully" do
    igniter = %MockIgniter{rewrite: nil}

    result = Igniter.find_all_matching_modules(igniter, fn _, _ -> true end)
    assert result == []
  end

  test "find_all_matching_modules with scan_all handles errors gracefully" do
    igniter = %MockIgniter{rewrite: nil}

    result = Igniter.find_all_matching_modules(igniter, fn _, _ -> true end, scan_all: true)
    assert result == []
  end
end

defp extract_function_code(code, func_name) do
  # Find the function definition
  func_pattern = ~r/defp #{func_name}[^{]*\{/s
  case Regex.run(func_pattern, code, return: :index) do
    [{start_pos, _length} | _] ->
      code_length = String.length(code)
      if start_pos < code_length do
        # Extract code starting from the opening brace (included in match)
        # Use explicit range to avoid negative step warnings
        remaining_code = String.slice(code, start_pos, code_length - start_pos)
        
        # Start with brace_count = 1 since we've already matched the opening brace
        # and include it in the result
        {func_code, _} = extract_balanced_braces(remaining_code, 1, "")
        func_code
      else
        ""
      end
    _ ->
      ""
  end
end

defp extract_balanced_braces(code, brace_count, acc) when brace_count < 0, do: {acc, code}
defp extract_balanced_braces("", _brace_count, acc), do: {acc, ""}
defp extract_balanced_braces(<<char::utf8, rest::binary>>, brace_count, acc) do
  new_count = case char do
    ?{ -> brace_count + 1
    ?} -> brace_count - 1
    _ -> brace_count
  end
  
  new_acc = acc <> <<char::utf8>>
  
  if new_count == 0 and brace_count > 0 do
    {new_acc, rest}
  else
    extract_balanced_braces(rest, new_count, new_acc)
  end
end

end
