{
  "@context": {
    "@vocab": "https://aalang.org/spec",
    "rdf": "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
    "rdfs": "http://www.w3.org/2000/01/rdf-schema#",
    "ex": "https://aalang.org/example/"
  },
  "@graph": [
    {
      "@id": "ex:Test_UnderstandingIndicatorsStateActor_UpdateConfidenceScores_HappyPath",
      "@type": "Test",
      "metadata": {
        "name": "Test_UnderstandingIndicatorsStateActor_UpdateConfidenceScores_HappyPath",
        "description": "Test successful update of understanding confidence scores with valid requirement aspects - UnderstandingIndicatorsStateActor should accept valid confidence scores and calculate overall confidence correctly",
        "type": "MessageResponseTest",
        "priority": 1
      },
      "setup": "Set up UnderstandingIndicatorsStateActor in ClarificationMode with initial empty state",
      "teardown": "Reset UnderstandingIndicatorsStateActor state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:UnderstandingIndicatorsStateActor"
            },
            "payload": {
              "action": "updateConfidenceScores",
              "requirementAspects": {
                "productType": 0.9,
                "coreFunctionality": 0.8,
                "constraints": 0.7,
                "edgeCases": 0.8
              }
            }
          }
        ]
      },
      "outputs": {
        "observedStateChanges": {
          "mode": "ex:ClarificationModeState",
          "stateChanges": {
            "requirementAspects": {
              "productType": 0.9,
              "coreFunctionality": 0.8,
              "constraints": 0.7,
              "edgeCases": 0.8
            },
            "overallConfidence": 0.8
          }
        },
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false
        }
      },
      "assertions": [
        {
          "type": "stateConsistency",
          "expected": "State is updated correctly with provided confidence scores",
          "deviationBounds": {
            "numericVariance": 0.01
          }
        },
        {
          "type": "satisfiesConstraint",
          "expected": "overallConfidence is calculated as weighted average: (0.3*productType + 0.3*coreFunctionality + 0.2*constraints + 0.2*edgeCases)"
        },
        {
          "type": "withinRange",
          "expected": "overallConfidence is between 0.0 and 1.0"
        },
        {
          "type": "actorBehavior",
          "expected": "UnderstandingIndicatorsStateActor accepts valid confidence score update"
        }
      ]
    },
    {
      "@id": "ex:Test_UnderstandingIndicatorsStateActor_UpdateConfidenceScores_Boundary",
      "@type": "Test",
      "metadata": {
        "name": "Test_UnderstandingIndicatorsStateActor_UpdateConfidenceScores_Boundary",
        "description": "Test boundary values for confidence scores - UnderstandingIndicatorsStateActor should handle minimum (0.0) and maximum (1.0) confidence values correctly",
        "type": "MessageResponseTest",
        "priority": 1
      },
      "setup": "Set up UnderstandingIndicatorsStateActor in ClarificationMode",
      "teardown": "Reset UnderstandingIndicatorsStateActor state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:UnderstandingIndicatorsStateActor"
            },
            "payload": {
              "action": "updateConfidenceScores",
              "requirementAspects": {
                "productType": 0.0,
                "coreFunctionality": 1.0,
                "constraints": 0.0,
                "edgeCases": 1.0
              }
            }
          }
        ]
      },
      "outputs": {
        "observedStateChanges": {
          "mode": "ex:ClarificationModeState",
          "stateChanges": {
            "requirementAspects": {
              "productType": 0.0,
              "coreFunctionality": 1.0,
              "constraints": 0.0,
              "edgeCases": 1.0
            },
            "overallConfidence": 0.4
          }
        },
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false
        }
      },
      "assertions": [
        {
          "type": "stateConsistency",
          "expected": "State accepts boundary values 0.0 and 1.0 without corruption"
        },
        {
          "type": "satisfiesConstraint",
          "expected": "overallConfidence calculation handles boundary values correctly"
        },
        {
          "type": "withinRange",
          "expected": "All individual scores and overallConfidence remain within 0.0-1.0 range"
        }
      ]
    },
    {
      "@id": "ex:Test_UnderstandingIndicatorsStateActor_UpdateConfidenceScores_InvalidInput",
      "@type": "Test",
      "metadata": {
        "name": "Test_UnderstandingIndicatorsStateActor_UpdateConfidenceScores_InvalidInput",
        "description": "Test rejection of invalid confidence scores - UnderstandingIndicatorsStateActor should reject negative values, values > 1.0, and non-numeric values",
        "type": "MessageResponseTest",
        "priority": 1
      },
      "setup": "Set up UnderstandingIndicatorsStateActor with initial valid state",
      "teardown": "Reset UnderstandingIndicatorsStateActor state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:UnderstandingIndicatorsStateActor"
            },
            "payload": {
              "action": "updateConfidenceScores",
              "requirementAspects": {
                "productType": -0.5,
                "coreFunctionality": 1.5,
                "constraints": "not_a_number",
                "edgeCases": null
              }
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:UnderstandingIndicatorsStateActor",
              "to": "user"
            },
            "payload": {
              "error": "Invalid confidence scores provided",
              "details": "Confidence scores must be numeric values between 0.0 and 1.0"
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": false,
          "messageRejected": true
        }
      },
      "assertions": [
        {
          "type": "excludes",
          "expected": "State should not be corrupted by invalid input values"
        },
        {
          "type": "contains",
          "expected": "Error message explains validation failure"
        },
        {
          "type": "satisfiesConstraint",
          "expected": "Invalid input does not corrupt existing valid state"
        },
        {
          "type": "actorBehavior",
          "expected": "UnderstandingIndicatorsStateActor rejects invalid confidence scores with clear error"
        }
      ]
    },
    {
      "@id": "ex:Test_UnderstandingIndicatorsStateActor_UpdateConfidenceScores_StateError",
      "@type": "Test",
      "metadata": {
        "name": "Test_UnderstandingIndicatorsStateActor_UpdateConfidenceScores_StateError",
        "description": "Test handling of corrupted state conditions - UnderstandingIndicatorsStateActor should handle null state values and invalid state transitions gracefully",
        "type": "MessageResponseTest",
        "priority": 1
      },
      "setup": "Corrupt UnderstandingIndicatorsStateActor state with null values",
      "teardown": "Reset UnderstandingIndicatorsStateActor state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:UnderstandingIndicatorsStateActor"
            },
            "payload": {
              "action": "updateConfidenceScores",
              "requirementAspects": {
                "productType": 0.8,
                "coreFunctionality": 0.7,
                "constraints": 0.9,
                "edgeCases": 0.6
              }
            }
          }
        ]
      },
      "outputs": {
        "observedStateChanges": {
          "mode": "ex:ClarificationModeState",
          "stateChanges": {
            "requirementAspects": {
              "productType": 0.8,
              "coreFunctionality": 0.7,
              "constraints": 0.9,
              "edgeCases": 0.6
            },
            "overallConfidence": 0.75
          }
        },
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false
        }
      },
      "assertions": [
        {
          "type": "stateConsistency",
          "expected": "Actor recovers from corrupted state and updates correctly"
        },
        {
          "type": "satisfiesConstraint",
          "expected": "State corruption does not prevent valid operations"
        },
        {
          "type": "excludes",
          "expected": "No crashes or undefined behavior when handling corrupted state"
        },
        {
          "type": "actorBehavior",
          "expected": "UnderstandingIndicatorsStateActor handles state errors gracefully"
        }
      ]
    },
    {
      "@id": "ex:Test_UnderstandingIndicatorsStateActor_UpdateConfidenceScores_EdgeCase",
      "@type": "Test",
      "metadata": {
        "name": "Test_UnderstandingIndicatorsStateActor_UpdateConfidenceScores_EdgeCase",
        "description": "Test rapid successive confidence score updates - UnderstandingIndicatorsStateActor should handle concurrent updates and maintain state consistency",
        "type": "MessageResponseTest",
        "priority": 1
      },
      "setup": "Set up UnderstandingIndicatorsStateActor with initial state",
      "teardown": "Reset UnderstandingIndicatorsStateActor state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:UnderstandingIndicatorsStateActor"
            },
            "payload": {
              "action": "updateConfidenceScores",
              "requirementAspects": {
                "productType": 0.5,
                "coreFunctionality": 0.5,
                "constraints": 0.5,
                "edgeCases": 0.5
              }
            }
          },
          {
            "routingGraph": {
              "to": "ex:UnderstandingIndicatorsStateActor"
            },
            "payload": {
              "action": "updateConfidenceScores",
              "requirementAspects": {
                "productType": 0.9,
                "coreFunctionality": 0.8,
                "constraints": 0.7,
                "edgeCases": 0.9
              }
            }
          }
        ],
        "messageSequence": [0, 1]
      },
      "outputs": {
        "observedStateChanges": {
          "mode": "ex:ClarificationModeState",
          "stateAfter": {
            "requirementAspects": {
              "productType": 0.9,
              "coreFunctionality": 0.8,
              "constraints": 0.7,
              "edgeCases": 0.9
            },
            "overallConfidence": 0.825
          }
        },
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false
        }
      },
      "assertions": [
        {
          "type": "followsSequence",
          "expected": ["First update processed", "Second update overwrites first", "Final state reflects most recent update"]
        },
        {
          "type": "stateConsistency",
          "expected": "Rapid successive updates maintain state consistency"
        },
        {
          "type": "satisfiesConstraint",
          "expected": "Each update is processed independently without interference"
        },
        {
          "type": "actorBehavior",
          "expected": "UnderstandingIndicatorsStateActor handles rapid updates correctly"
        }
      ]
    },
    {
      "@id": "ex:Test_SatisfactionIndicatorsStateActor_UpdateSatisfaction_HappyPath",
      "@type": "Test",
      "metadata": {
        "name": "Test_SatisfactionIndicatorsStateActor_UpdateSatisfaction_HappyPath",
        "description": "Test successful update of mode satisfaction indicators - SatisfactionIndicatorsStateActor should accept valid satisfaction updates for mode transitions",
        "type": "MessageResponseTest",
        "priority": 1
      },
      "setup": "Set up SatisfactionIndicatorsStateActor with initial empty state",
      "teardown": "Reset SatisfactionIndicatorsStateActor state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:SatisfactionIndicatorsStateActor"
            },
            "payload": {
              "action": "updateSatisfaction",
              "discussionMode": {
                "satisfied": true,
                "confident": true,
                "consensus": true
              }
            }
          }
        ]
      },
      "outputs": {
        "observedStateChanges": {
          "mode": "ex:TestResultReportingModeState",
          "stateChanges": {
            "discussionMode": {
              "satisfied": true,
              "confident": true,
              "consensus": true
            },
            "generationReadiness": {
              "ready": false
            }
          }
        },
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false
        }
      },
      "assertions": [
        {
          "type": "stateConsistency",
          "expected": "State is updated correctly with provided satisfaction indicators"
        },
        {
          "type": "satisfiesConstraint",
          "expected": "generationReadiness.ready is false when only discussionMode is satisfied"
        },
        {
          "type": "hasProperty",
          "expected": "All required satisfaction properties are present and correctly set"
        },
        {
          "type": "actorBehavior",
          "expected": "SatisfactionIndicatorsStateActor accepts valid satisfaction updates"
        }
      ]
    },
    {
      "@id": "ex:Test_SatisfactionIndicatorsStateActor_UpdateSatisfaction_Boundary",
      "@type": "Test",
      "metadata": {
        "name": "Test_SatisfactionIndicatorsStateActor_UpdateSatisfaction_Boundary",
        "description": "Test boundary conditions for satisfaction indicators - SatisfactionIndicatorsStateActor should handle all-true and all-false combinations correctly",
        "type": "MessageResponseTest",
        "priority": 1
      },
      "setup": "Set up SatisfactionIndicatorsStateActor",
      "teardown": "Reset SatisfactionIndicatorsStateActor state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:SatisfactionIndicatorsStateActor"
            },
            "payload": {
              "action": "updateSatisfaction",
              "formalizationMode": {
                "satisfied": false,
                "confident": false,
                "consensus": false,
                "skipped": true
              }
            }
          }
        ]
      },
      "outputs": {
        "observedStateChanges": {
          "mode": "ex:TestResultReportingModeState",
          "stateChanges": {
            "formalizationMode": {
              "satisfied": false,
              "confident": false,
              "consensus": false,
              "skipped": true
            },
            "generationReadiness": {
              "ready": false
            }
          }
        },
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false
        }
      },
      "assertions": [
        {
          "type": "stateConsistency",
          "expected": "State handles boundary condition of skipped=true with false satisfaction indicators"
        },
        {
          "type": "satisfiesConstraint",
          "expected": "generationReadiness.ready remains false when formalization is skipped but discussion not satisfied"
        },
        {
          "type": "hasProperty",
          "expected": "Skipped flag is properly stored and accessible"
        }
      ]
    },
    {
      "@id": "ex:Test_SatisfactionIndicatorsStateActor_UpdateSatisfaction_InvalidInput",
      "@type": "Test",
      "metadata": {
        "name": "Test_SatisfactionIndicatorsStateActor_UpdateSatisfaction_InvalidInput",
        "description": "Test rejection of invalid satisfaction updates - SatisfactionIndicatorsStateActor should reject non-boolean values and invalid mode names",
        "type": "MessageResponseTest",
        "priority": 1
      },
      "setup": "Set up SatisfactionIndicatorsStateActor with valid initial state",
      "teardown": "Reset SatisfactionIndicatorsStateActor state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:SatisfactionIndicatorsStateActor"
            },
            "payload": {
              "action": "updateSatisfaction",
              "invalidMode": {
                "satisfied": "not_boolean",
                "confident": null,
                "consensus": 123
              }
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:SatisfactionIndicatorsStateActor",
              "to": "user"
            },
            "payload": {
              "error": "Invalid satisfaction update",
              "details": "Satisfaction indicators must be boolean values, mode must be valid"
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": false,
          "messageRejected": true
        }
      },
      "assertions": [
        {
          "type": "excludes",
          "expected": "Invalid input does not corrupt existing state"
        },
        {
          "type": "contains",
          "expected": "Error message specifies validation requirements"
        },
        {
          "type": "satisfiesConstraint",
          "expected": "Invalid updates are rejected without affecting valid state"
        },
        {
          "type": "actorBehavior",
          "expected": "SatisfactionIndicatorsStateActor rejects invalid satisfaction updates"
        }
      ]
    },
    {
      "@id": "ex:Test_ProductNameStateActor_SetProductName_HappyPath",
      "@type": "Test",
      "metadata": {
        "name": "Test_ProductNameStateActor_SetProductName_HappyPath",
        "description": "Test successful product name setting - ProductNameStateActor should accept valid filesystem-safe product names",
        "type": "MessageResponseTest",
        "priority": 1
      },
      "setup": "Set up ProductNameStateActor with empty state",
      "teardown": "Reset ProductNameStateActor state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:ProductNameStateActor"
            },
            "payload": {
              "action": "setProductName",
              "productName": "number-guessing-game"
            }
          }
        ]
      },
      "outputs": {
        "observedStateChanges": {
          "mode": "ex:TestNeedEvaluationModeState",
          "stateChanges": {
            "productName": "number-guessing-game",
            "nameValidated": true
          }
        },
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false
        }
      },
      "assertions": [
        {
          "type": "stateConsistency",
          "expected": "Product name is stored correctly"
        },
        {
          "type": "satisfiesConstraint",
          "expected": "Filesystem-safe name is accepted"
        },
        {
          "type": "hasProperty",
          "expected": "nameValidated flag is set to true for valid names"
        },
        {
          "type": "actorBehavior",
          "expected": "ProductNameStateActor accepts valid filesystem-safe product names"
        }
      ]
    },
    {
      "@id": "ex:Test_ProductNameStateActor_SetProductName_InvalidInput",
      "@type": "Test",
      "metadata": {
        "name": "Test_ProductNameStateActor_SetProductName_InvalidInput",
        "description": "Test rejection of invalid product names - ProductNameStateActor should reject names with invalid characters, spaces, or special symbols",
        "type": "MessageResponseTest",
        "priority": 1
      },
      "setup": "Set up ProductNameStateActor",
      "teardown": "Reset ProductNameStateActor state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:ProductNameStateActor"
            },
            "payload": {
              "action": "setProductName",
              "productName": "invalid name with spaces!"
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:ProductNameStateActor",
              "to": "user"
            },
            "payload": {
              "error": "Invalid product name",
              "details": "Product name must be filesystem-safe: alphanumeric, hyphens, underscores only"
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": false,
          "messageRejected": true
        }
      },
      "assertions": [
        {
          "type": "excludes",
          "expected": "Invalid product name is not stored in state"
        },
        {
          "type": "contains",
          "expected": "Error message specifies filesystem-safe requirements"
        },
        {
          "type": "satisfiesConstraint",
          "expected": "Invalid names do not corrupt existing valid state"
        },
        {
          "type": "actorBehavior",
          "expected": "ProductNameStateActor rejects invalid product names with clear error"
        }
      ]
    },
    {
      "@id": "ex:Test_ClarificationActor1_AnalyzeAmbiguities_HappyPath",
      "@type": "Test",
      "metadata": {
        "name": "Test_ClarificationActor1_AnalyzeAmbiguities_HappyPath",
        "description": "Test successful ambiguity analysis in user requirements - ClarificationActor1 should identify clear, unambiguous requirements and calculate high confidence scores",
        "type": "MessageResponseTest",
        "priority": 2
      },
      "setup": "Set up ClarificationActor1 in ClarificationMode with clear user requirements",
      "teardown": "Reset ClarificationMode state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:ClarificationActor1"
            },
            "payload": {
              "action": "analyzeRequirements",
              "userRequirements": "I want to build a simple FAQ chatbot that answers customer questions about product pricing and features. It should use a predefined knowledge base and not require complex integrations."
            }
          }
        ]
      },
      "outputs": {
        "observedStateChanges": {
          "mode": "ex:ClarificationModeState",
          "stateChanges": {
            "requirementAspects": {
              "productType": 0.9,
              "coreFunctionality": 0.8,
              "constraints": 0.8,
              "edgeCases": 0.7
            }
          }
        },
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:ClarificationActor1",
              "to": "ex:UnderstandingIndicatorsStatePersona"
            },
            "payload": {
              "requirementAspects": {
                "productType": 0.9,
                "coreFunctionality": 0.8,
                "constraints": 0.8,
                "edgeCases": 0.7
              }
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false,
          "ambiguitiesDetected": false
        }
      },
      "assertions": [
        {
          "type": "stateConsistency",
          "expected": "State updated with appropriate confidence scores for clear requirements"
        },
        {
          "type": "satisfiesConstraint",
          "expected": "High confidence scores (0.7-0.9) assigned to clearly specified aspects"
        },
        {
          "type": "messageFormat",
          "expected": "State update message follows AALang format with proper routing"
        },
        {
          "type": "actorBehavior",
          "expected": "ClarificationActor1 correctly identifies clear, unambiguous requirements"
        }
      ]
    },
    {
      "@id": "ex:Test_ClarificationActor1_AnalyzeAmbiguities_Boundary",
      "@type": "Test",
      "metadata": {
        "name": "Test_ClarificationActor1_AnalyzeAmbiguities_Boundary",
        "description": "Test boundary analysis of partially clear requirements - ClarificationActor1 should assign medium confidence scores (0.4-0.6) to partially understood aspects",
        "type": "MessageResponseTest",
        "priority": 2
      },
      "setup": "Set up ClarificationActor1 with moderately ambiguous requirements",
      "teardown": "Reset ClarificationMode state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:ClarificationActor1"
            },
            "payload": {
              "action": "analyzeRequirements",
              "userRequirements": "I need a tool that can process some data and maybe generate reports. It should work somehow."
            }
          }
        ]
      },
      "outputs": {
        "observedStateChanges": {
          "mode": "ex:ClarificationModeState",
          "stateChanges": {
            "requirementAspects": {
              "productType": 0.5,
              "coreFunctionality": 0.4,
              "constraints": 0.3,
              "edgeCases": 0.2
            }
          }
        },
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false,
          "ambiguitiesDetected": true
        }
      },
      "assertions": [
        {
          "type": "withinRange",
          "expected": "Confidence scores in medium range (0.4-0.6) for partially clear aspects"
        },
        {
          "type": "satisfiesConstraint",
          "expected": "Lower scores (0.0-0.3) for unclear or missing aspects"
        },
        {
          "type": "stateConsistency",
          "expected": "Boundary confidence scores properly calculated and stored"
        },
        {
          "type": "actorBehavior",
          "expected": "ClarificationActor1 assigns appropriate medium confidence to partially understood requirements"
        }
      ]
    },
    {
      "@id": "ex:Test_ClarificationActor1_AnalyzeAmbiguities_InvalidInput",
      "@type": "Test",
      "metadata": {
        "name": "Test_ClarificationActor1_AnalyzeAmbiguities_InvalidInput",
        "description": "Test rejection of completely invalid or missing requirements - ClarificationActor1 should reject empty, null, or nonsensical input",
        "type": "MessageResponseTest",
        "priority": 2
      },
      "setup": "Set up ClarificationActor1 with expectation of valid requirements",
      "teardown": "Reset ClarificationMode state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:ClarificationActor1"
            },
            "payload": {
              "action": "analyzeRequirements",
              "userRequirements": ""
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:ClarificationActor1",
              "to": "user"
            },
            "payload": {
              "error": "Invalid requirements provided",
              "details": "Requirements cannot be empty or null. Please provide a description of what you want to build."
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": false,
          "messageRejected": true
        }
      },
      "assertions": [
        {
          "type": "excludes",
          "expected": "State should not be updated with invalid input"
        },
        {
          "type": "contains",
          "expected": "Error message explains validation failure"
        },
        {
          "type": "satisfiesConstraint",
          "expected": "Invalid input does not corrupt existing state"
        },
        {
          "type": "actorBehavior",
          "expected": "ClarificationActor1 rejects empty or invalid requirements with clear error"
        }
      ]
    },
    {
      "@id": "ex:Test_ClarificationActor1_ProductTypeDetection_HappyPath",
      "@type": "Test",
      "metadata": {
        "name": "Test_ClarificationActor1_ProductTypeDetection_HappyPath",
        "description": "Test successful product type detection - ClarificationActor1 should correctly identify AALang product types from clear requirements",
        "type": "MessageResponseTest",
        "priority": 2
      },
      "setup": "Set up ClarificationActor1 with clear product type requirements",
      "teardown": "Reset ClarificationMode state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:ClarificationActor1"
            },
            "payload": {
              "action": "detectProductType",
              "userRequirements": "Create a JSON-LD based tool that can analyze code files and generate reports. It should be an AALang tool that follows the specification."
            }
          }
        ]
      },
      "outputs": {
        "observedStateChanges": {
          "mode": "ex:ClarificationModeState",
          "stateChanges": {
            "detectedProductType": "AALang Tool",
            "productTypeConfidence": 0.9
          }
        },
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false,
          "productTypeIdentified": true
        }
      },
      "assertions": [
        {
          "type": "satisfiesConstraint",
          "expected": "Correctly identifies 'AALang Tool' as product type"
        },
        {
          "type": "withinRange",
          "expected": "High confidence score (0.8+) for clearly specified product type"
        },
        {
          "type": "stateConsistency",
          "expected": "Product type detection results stored in state"
        },
        {
          "type": "actorBehavior",
          "expected": "ClarificationActor1 correctly identifies AALang product types"
        }
      ]
    },
    {
      "@id": "ex:Test_ClarificationActor1_ProductNameIdentification_HappyPath",
      "@type": "Test",
      "metadata": {
        "name": "Test_ClarificationActor1_ProductNameIdentification_HappyPath",
        "description": "Test successful product name identification - ClarificationActor1 should extract filesystem-safe product names from requirements",
        "type": "MessageResponseTest",
        "priority": 2
      },
      "setup": "Set up ClarificationActor1 with requirements containing clear product name",
      "teardown": "Reset ClarificationMode state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:ClarificationActor1"
            },
            "payload": {
              "action": "identifyProductName",
              "userRequirements": "Build a code analysis tool called CodeAnalyzer that processes source files."
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:ClarificationActor1",
              "to": "ex:ProductNameStatePersona"
            },
            "payload": {
              "action": "setProductName",
              "productName": "code-analyzer",
              "source": "extracted from user requirements"
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false,
          "productNameExtracted": true
        }
      },
      "assertions": [
        {
          "type": "satisfiesConstraint",
          "expected": "Extracts filesystem-safe name 'code-analyzer' from 'CodeAnalyzer'"
        },
        {
          "type": "messageFormat",
          "expected": "Product name update sent to ProductNameStatePersona"
        },
        {
          "type": "actorBehavior",
          "expected": "ClarificationActor1 correctly identifies and formats product names"
        },
        {
          "type": "stateConsistency",
          "expected": "Product name identification communicated to state management"
        }
      ]
    },
    {
      "@id": "ex:Test_ClarificationActor1_ProductNameIdentification_InvalidInput",
      "@type": "Test",
      "metadata": {
        "name": "Test_ClarificationActor1_ProductNameIdentification_InvalidInput",
        "description": "Test rejection of invalid product names - ClarificationActor1 should reject names with invalid characters and request correction",
        "type": "MessageResponseTest",
        "priority": 2
      },
      "setup": "Set up ClarificationActor1 with requirements containing invalid product name",
      "teardown": "Reset ClarificationMode state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:ClarificationActor1"
            },
            "payload": {
              "action": "identifyProductName",
              "userRequirements": "Build a tool called 'My Awesome Tool!' with special characters."
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:ClarificationActor1",
              "to": "user"
            },
            "payload": {
              "message": "Product name 'My Awesome Tool!' contains invalid characters. Please provide a filesystem-safe name using only alphanumeric characters, hyphens, and underscores.",
              "action": "request_name_correction"
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false,
          "invalidNameDetected": true
        }
      },
      "assertions": [
        {
          "type": "excludes",
          "expected": "Invalid product name should not be sent to ProductNameStatePersona"
        },
        {
          "type": "contains",
          "expected": "Error message specifies filesystem-safe requirements"
        },
        {
          "type": "satisfiesConstraint",
          "expected": "Invalid characters (!@#$%^&*()) are properly rejected"
        },
        {
          "type": "actorBehavior",
          "expected": "ClarificationActor1 validates product name format before proceeding"
        }
      ]
    },
    {
      "@id": "ex:Test_ClarificationActor1_ConfidenceThresholdEnforcement_HappyPath",
      "@type": "Test",
      "metadata": {
        "name": "Test_ClarificationActor1_ConfidenceThresholdEnforcement_HappyPath",
        "description": "Test proper enforcement of confidence threshold - ClarificationActor1 should allow progression when overallConfidence >= 0.8",
        "type": "MessageResponseTest",
        "priority": 2
      },
      "setup": "Set up ClarificationActor1 with UnderstandingIndicatorsStateActor showing overallConfidence = 0.85",
      "teardown": "Reset ClarificationMode state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:ClarificationActor1"
            },
            "payload": {
              "action": "checkProgressionReadiness",
              "requestType": "mode_transition_check"
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:ClarificationActor1",
              "to": "ex:DiscussionPersona1"
            },
            "payload": {
              "action": "transitionToDiscussionMode",
              "confidenceVerified": true,
              "overallConfidence": 0.85
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false,
          "transitionAllowed": true
        }
      },
      "assertions": [
        {
          "type": "satisfiesConstraint",
          "expected": "Allows transition when overallConfidence >= 0.8"
        },
        {
          "type": "modeTransition",
          "expected": "Successfully initiates transition to DiscussionMode"
        },
        {
          "type": "followsSequence",
          "expected": ["Confidence check performed", "Threshold met verified", "Transition message sent"]
        },
        {
          "type": "actorBehavior",
          "expected": "ClarificationActor1 properly enforces confidence threshold for mode transitions"
        }
      ]
    },
    {
      "@id": "ex:Test_ClarificationActor1_ConfidenceThresholdEnforcement_Blocked",
      "@type": "Test",
      "metadata": {
        "name": "Test_ClarificationActor1_ConfidenceThresholdEnforcement_Blocked",
        "description": "Test blocking of transition below confidence threshold - ClarificationActor1 should prevent progression when overallConfidence < 0.8",
        "type": "MessageResponseTest",
        "priority": 2
      },
      "setup": "Set up ClarificationActor1 with UnderstandingIndicatorsStateActor showing overallConfidence = 0.6",
      "teardown": "Reset ClarificationMode state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:ClarificationActor1"
            },
            "payload": {
              "action": "checkProgressionReadiness",
              "requestType": "mode_transition_check"
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:ClarificationActor1",
              "to": "user"
            },
            "payload": {
              "message": "Cannot proceed to Discussion Mode: understanding confidence (0.6) is below required threshold (0.8). More clarification needed.",
              "action": "continue_clarification"
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false,
          "transitionBlocked": true
        }
      },
      "assertions": [
        {
          "type": "excludes",
          "expected": "Transition message should not be sent when confidence < 0.8"
        },
        {
          "type": "satisfiesConstraint",
          "expected": "Blocks transition when overallConfidence < 0.8"
        },
        {
          "type": "contains",
          "expected": "User message explains confidence requirement and requests continuation"
        },
        {
          "type": "actorBehavior",
          "expected": "ClarificationActor1 correctly blocks insufficient confidence transitions"
        }
      ]
    },
    {
      "@id": "ex:Test_ClarificationActor1_ClarificationQuestionFormatting_HappyPath",
      "@type": "Test",
      "metadata": {
        "name": "Test_ClarificationActor1_ClarificationQuestionFormatting_HappyPath",
        "description": "Test proper formatting of clarification questions - ClarificationActor1 should use numbered lists for questions, issues, and concerns",
        "type": "MessageResponseTest",
        "priority": 2
      },
      "setup": "Set up ClarificationActor1 with ambiguous requirements requiring clarification questions",
      "teardown": "Reset ClarificationMode state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:ClarificationActor1"
            },
            "payload": {
              "action": "generateClarificationQuestions",
              "ambiguities": [
                "Product type unclear",
                "Missing functionality details",
                "Integration requirements unspecified"
              ]
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:ClarificationActor1",
              "to": "user"
            },
            "payload": {
              "message": "To help clarify your requirements, I need to understand:",
              "questions": [
                "1. What type of product do you want to build (AALang prompt, agent, protocol, tool, etc.)?",
                "2. What specific functionality should the product provide?",
                "3. What systems need to be integrated and how?"
              ]
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false,
          "questionsFormatted": true
        }
      },
      "assertions": [
        {
          "type": "contains",
          "expected": "Questions formatted with numbered list (1., 2., 3.)"
        },
        {
          "type": "satisfiesConstraint",
          "expected": "No bulleted lists (-, â€¢) used for questions"
        },
        {
          "type": "hasStructure",
          "expected": "Questions array contains properly formatted question strings"
        },
        {
          "type": "actorBehavior",
          "expected": "ClarificationActor1 uses numbered lists for clarification questions as required"
        }
      ]
    },
    {
      "@id": "ex:Test_ClarificationActor2_ChallengeAssumptions_HappyPath",
      "@type": "Test",
      "metadata": {
        "name": "Test_ClarificationActor2_ChallengeAssumptions_HappyPath",
        "description": "Test successful assumption challenging - ClarificationActor2 should identify implicit assumptions and propose 'what if' questions",
        "type": "MessageResponseTest",
        "priority": 2
      },
      "setup": "Set up ClarificationActor2 with requirements containing implicit assumptions",
      "teardown": "Reset ClarificationMode state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:ClarificationActor2"
            },
            "payload": {
              "action": "challengeAssumptions",
              "userRequirements": "Build a simple chatbot that answers questions. It should work perfectly."
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:ClarificationActor2",
              "to": "ex:ClarificationActor1"
            },
            "payload": {
              "action": "additionalClarificationQuestions",
              "questions": [
                "1. What if users ask questions outside the chatbot's knowledge scope?",
                "2. What if the chatbot receives malformed or malicious input?",
                "3. What if multiple users interact simultaneously?",
                "4. What constitutes 'working perfectly' - what error rate is acceptable?"
              ]
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false,
          "assumptionsChallenged": true
        }
      },
      "assertions": [
        {
          "type": "contains",
          "expected": "Questions use 'what if' format to challenge assumptions"
        },
        {
          "type": "satisfiesConstraint",
          "expected": "Identifies edge cases: error handling, concurrent users, scope limitations"
        },
        {
          "type": "hasStructure",
          "expected": "Questions formatted as numbered list"
        },
        {
          "type": "actorBehavior",
          "expected": "ClarificationActor2 proactively identifies implicit assumptions and edge cases"
        }
      ]
    },
    {
      "@id": "ex:Test_ClarificationActor2_ImplicitRequirementsIdentification_HappyPath",
      "@type": "Test",
      "metadata": {
        "name": "Test_ClarificationActor2_ImplicitRequirementsIdentification_HappyPath",
        "description": "Test identification of implicit requirements - ClarificationActor2 should make explicit requirements that were only implied",
        "type": "MessageResponseTest",
        "priority": 2
      },
      "setup": "Set up ClarificationActor2 with requirements containing implicit needs",
      "teardown": "Reset ClarificationMode state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:ClarificationActor2"
            },
            "payload": {
              "action": "identifyImplicitRequirements",
              "userRequirements": "Create a web application for user registration."
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:ClarificationActor2",
              "to": "ex:ClarificationActor1"
            },
            "payload": {
              "action": "implicitRequirementsFound",
              "implicitRequirements": [
                "1. User data storage and database design",
                "2. Password security and encryption",
                "3. Input validation and sanitization",
                "4. Session management and authentication",
                "5. Error handling and user feedback",
                "6. Security measures against common attacks"
              ]
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false,
          "implicitRequirementsIdentified": true
        }
      },
      "assertions": [
        {
          "type": "satisfiesConstraint",
          "expected": "Identifies security, data management, and error handling as implicit requirements"
        },
        {
          "type": "contains",
          "expected": "Makes explicit security requirements (encryption, validation, attack prevention)"
        },
        {
          "type": "hasStructure",
          "expected": "Implicit requirements presented as numbered list"
        },
        {
          "type": "actorBehavior",
          "expected": "ClarificationActor2 identifies requirements beyond explicit user statements"
        }
      ]
    },
    {
      "@id": "ex:Test_ClarificationActor2_UnderstandingVerification_HappyPath",
      "@type": "Test",
      "metadata": {
        "name": "Test_ClarificationActor2_UnderstandingVerification_HappyPath",
        "description": "Test understanding verification suggestions - ClarificationActor2 should propose ways to confirm understanding of requirements",
        "type": "MessageResponseTest",
        "priority": 2
      },
      "setup": "Set up ClarificationActor2 with analyzed requirements needing verification",
      "teardown": "Reset ClarificationMode state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:ClarificationActor2"
            },
            "payload": {
              "action": "suggestUnderstandingVerification",
              "currentUnderstanding": {
                "productType": "unclear",
                "functionality": "partially_understood",
                "constraints": "understood"
              }
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:ClarificationActor2",
              "to": "ex:ClarificationActor1"
            },
            "payload": {
              "action": "verificationSuggestions",
              "suggestions": [
                "1. Can you confirm if this should be an AALang agent or a simpler prompt?",
                "2. Should I assume standard web technologies, or do you have specific tech requirements?",
                "3. Would you like me to create a small prototype to verify my understanding?",
                "4. Can you review and correct any misunderstandings in my interpretation?"
              ]
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false,
          "verificationMethodsSuggested": true
        }
      },
      "assertions": [
        {
          "type": "contains",
          "expected": "Suggests confirmation questions ('Can you confirm...')"
        },
        {
          "type": "satisfiesConstraint",
          "expected": "Proposes multiple verification methods: confirmation, prototyping, review"
        },
        {
          "type": "hasStructure",
          "expected": "Suggestions formatted as numbered list"
        },
        {
          "type": "actorBehavior",
          "expected": "ClarificationActor2 provides concrete methods to verify understanding"
        }
      ]
    },
    {
      "@id": "ex:Test_DiscussionActor1_ProblemDecomposition_HappyPath",
      "@type": "Test",
      "metadata": {
        "name": "Test_DiscussionActor1_ProblemDecomposition_HappyPath",
        "description": "Test successful problem decomposition - DiscussionActor1 should break down user requirements into required modes, actors, and agents",
        "type": "MessageResponseTest",
        "priority": 2
      },
      "setup": "Set up DiscussionActor1 in DiscussionMode with clarified requirements",
      "teardown": "Reset DiscussionMode state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:DiscussionActor1"
            },
            "payload": {
              "action": "decomposeProblem",
              "requirements": "Build an FAQ chatbot that answers customer questions about products, integrates with CRM, and handles multiple users simultaneously"
            }
          }
        ]
      },
      "outputs": {
        "observedStateChanges": {
          "mode": "ex:DiscussionModeState",
          "stateChanges": {
            "proposedStructure": {
              "modes": ["QueryProcessingMode", "CRMIntegrationMode", "ResponseGenerationMode"],
              "actors": ["QuestionAnalyzer", "CRMConnector", "ResponseBuilder", "SessionManager"],
              "communicationPatterns": ["actor-to-actor messaging", "state management", "user interaction"]
            }
          }
        },
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false,
          "decompositionCompleted": true
        }
      },
      "assertions": [
        {
          "type": "satisfiesConstraint",
          "expected": "Identifies appropriate modes for different functional areas"
        },
        {
          "type": "hasStructure",
          "expected": "Proposes complete actor set covering all requirements"
        },
        {
          "type": "satisfiesConstraint",
          "expected": "Includes communication patterns and state management"
        },
        {
          "type": "actorBehavior",
          "expected": "DiscussionActor1 performs systematic problem decomposition in natural language"
        }
      ]
    },
    {
      "@id": "ex:Test_DiscussionActor1_DesignProposal_HappyPath",
      "@type": "Test",
      "metadata": {
        "name": "Test_DiscussionActor1_DesignProposal_HappyPath",
        "description": "Test successful design proposal creation - DiscussionActor1 should propose complete AALang-compliant designs with proper structure",
        "type": "MessageResponseTest",
        "priority": 2
      },
      "setup": "Set up DiscussionActor1 with decomposed problem structure",
      "teardown": "Reset DiscussionMode state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:DiscussionActor1"
            },
            "payload": {
              "action": "proposeDesign",
              "decomposedProblem": {
                "coreFunctionality": "FAQ chatbot",
                "integrations": ["CRM system"],
                "concurrency": "multiple users"
              }
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:DiscussionActor1",
              "to": "user"
            },
            "payload": {
              "message": "Based on the problem decomposition, I propose this AALang agent design:",
              "proposedDesign": {
                "productType": "AALang Agent",
                "structure": "4-mode-6-actor pattern",
                "modes": [
                  "QueryProcessingMode: Handles user questions and routing",
                  "CRMIntegrationMode: Manages CRM data access",
                  "ResponseGenerationMode: Creates appropriate responses",
                  "SessionManagementMode: Handles concurrent users"
                ],
                "keyActors": [
                  "QuestionRouter (routes questions to appropriate handlers)",
                  "CRMConnector (manages CRM integration)",
                  "ResponseBuilder (constructs answers)",
                  "SessionTracker (manages user sessions)"
                ]
              }
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false,
          "designProposed": true
        }
      },
      "assertions": [
        {
          "type": "satisfiesConstraint",
          "expected": "Proposes valid AALang agent structure (n-mode-m-actor pattern)"
        },
        {
          "type": "contains",
          "expected": "Includes all required functional areas from requirements"
        },
        {
          "type": "hasStructure",
          "expected": "Design includes modes, actors, and communication patterns"
        },
        {
          "type": "actorBehavior",
          "expected": "DiscussionActor1 proposes designs following AALang specifications"
        }
      ]
    },
    {
      "@id": "ex:Test_DiscussionActor1_NonAALangPushback_HappyPath",
      "@type": "Test",
      "metadata": {
        "name": "Test_DiscussionActor1_NonAALangPushback_HappyPath",
        "description": "Test proper pushback on non-AALang approaches - DiscussionActor1 should identify and push back on approaches that don't follow AALang patterns",
        "type": "MessageResponseTest",
        "priority": 2
      },
      "setup": "Set up DiscussionActor1 with user proposing non-AALang approach",
      "teardown": "Reset DiscussionMode state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:DiscussionActor1"
            },
            "payload": {
              "action": "reviewApproach",
              "proposedApproach": "Let's build this as a standard Python script that directly calls the CRM API"
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:DiscussionActor1",
              "to": "user"
            },
            "payload": {
              "message": "I notice you're proposing a direct API approach, but this violates AALang design principles:",
              "violationAnalysis": [
                "1. Direct API calls don't follow AALang's actor-based communication",
                "2. Python scripts aren't AALang products (should be JSON-LD specifications)",
                "3. This approach lacks the structured mode/actor pattern"
              ],
              "aalangAlternative": "Instead, I recommend an AALang agent with a CRMIntegrationMode containing CRMConnector and CRMDataProcessor actors that communicate via AALang messages."
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false,
          "pushbackProvided": true
        }
      },
      "assertions": [
        {
          "type": "contains",
          "expected": "Clearly identifies the specific AALang violation"
        },
        {
          "type": "satisfiesConstraint",
          "expected": "Provides specific AALang-compliant alternative"
        },
        {
          "type": "hasStructure",
          "expected": "Pushback includes numbered list of violations"
        },
        {
          "type": "actorBehavior",
          "expected": "DiscussionActor1 actively pushes back on non-AALang approaches with alternatives"
        }
      ]
    },
    {
      "@id": "ex:Test_DiscussionActor1_SatisfactionIndicators_HappyPath",
      "@type": "Test",
      "metadata": {
        "name": "Test_DiscussionActor1_SatisfactionIndicators_HappyPath",
        "description": "Test proper satisfaction indicator setting - DiscussionActor1 should set satisfaction indicators when consensus is reached",
        "type": "MessageResponseTest",
        "priority": 2
      },
      "setup": "Set up DiscussionActor1 with completed design discussion and user agreement",
      "teardown": "Reset DiscussionMode state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:DiscussionActor1"
            },
            "payload": {
              "action": "finalizeDiscussion",
              "userAgreement": "Yes, the proposed design looks good. I agree with the structure."
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:DiscussionActor1",
              "to": "ex:SatisfactionIndicatorsStatePersona"
            },
            "payload": {
              "action": "updateSatisfaction",
              "discussionMode": {
                "satisfied": true,
                "confident": true,
                "consensus": true
              }
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false,
          "satisfactionSet": true
        }
      },
      "assertions": [
        {
          "type": "satisfiesConstraint",
          "expected": "Sets all three satisfaction indicators: satisfied, confident, consensus"
        },
        {
          "type": "messageFormat",
          "expected": "Satisfaction update sent to correct state management actor"
        },
        {
          "type": "stateConsistency",
          "expected": "Satisfaction indicators properly stored for mode transition validation"
        },
        {
          "type": "actorBehavior",
          "expected": "DiscussionActor1 correctly manages discussion completion and satisfaction tracking"
        }
      ]
    },
    {
      "@id": "ex:Test_DiscussionActor2_AlternativePerspectives_HappyPath",
      "@type": "Test",
      "metadata": {
        "name": "Test_DiscussionActor2_AlternativePerspectives_HappyPath",
        "description": "Test provision of alternative design perspectives - DiscussionActor2 should offer different approaches and consider latest AALang developments",
        "type": "MessageResponseTest",
        "priority": 2
      },
      "setup": "Set up DiscussionActor2 with DiscussionActor1's design proposal",
      "teardown": "Reset DiscussionMode state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:DiscussionActor2"
            },
            "payload": {
              "action": "reviewDesignProposal",
              "proposal": {
                "approach": "Traditional 4-mode agent",
                "structure": "Sequential mode progression"
              }
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:DiscussionActor2",
              "to": "ex:DiscussionActor1"
            },
            "payload": {
              "action": "alternativePerspective",
              "alternatives": [
                "1. Consider a more dynamic mode structure using conditional transitions based on user context",
                "2. Explore hierarchical actor patterns where some actors coordinate sub-teams",
                "3. Consider event-driven communication instead of sequential processing"
              ],
              "rationale": "Recent AALang developments suggest more flexible architectures may better handle complex user interactions"
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false,
          "alternativesProposed": true
        }
      },
      "assertions": [
        {
          "type": "contains",
          "expected": "References recent AALang developments as rationale"
        },
        {
          "type": "satisfiesConstraint",
          "expected": "Provides concrete alternative approaches, not just criticism"
        },
        {
          "type": "hasStructure",
          "expected": "Alternatives presented as numbered list"
        },
        {
          "type": "actorBehavior",
          "expected": "DiscussionActor2 offers innovative alternatives while respecting existing proposals"
        }
      ]
    },
    {
      "@id": "ex:Test_DiscussionActor2_BalancedCritique_HappyPath",
      "@type": "Test",
      "metadata": {
        "name": "Test_DiscussionActor2_BalancedCritique_HappyPath",
        "description": "Test balanced critique capability - DiscussionActor2 should support good ideas while constructively challenging flawed approaches",
        "type": "MessageResponseTest",
        "priority": 2
      },
      "setup": "Set up DiscussionActor2 with both strong and weak design elements",
      "teardown": "Reset DiscussionMode state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:DiscussionActor2"
            },
            "payload": {
              "action": "provideCritique",
              "designElements": {
                "good": "Clear actor separation of concerns",
                "problematic": "Overly rigid mode transitions",
                "innovative": "Context-aware state management"
              }
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:DiscussionActor2",
              "to": "ex:DiscussionActor1"
            },
            "payload": {
              "action": "balancedFeedback",
              "positiveFeedback": [
                "1. Excellent separation of concerns - this will improve maintainability",
                "2. Context-aware state management is a great innovation"
              ],
              "constructiveSuggestions": [
                "1. Consider conditional transitions for more flexibility",
                "2. Could explore event-driven triggers for mode changes"
              ]
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false,
          "balancedCritiqueProvided": true
        }
      },
      "assertions": [
        {
          "type": "contains",
          "expected": "Includes both positive feedback and constructive suggestions"
        },
        {
          "type": "satisfiesConstraint",
          "expected": "Provides specific, actionable improvement suggestions"
        },
        {
          "type": "hasStructure",
          "expected": "Separates positive and constructive feedback clearly"
        },
        {
          "type": "actorBehavior",
          "expected": "DiscussionActor2 provides balanced critique that supports good ideas and improves weak ones"
        }
      ]
    },
    {
      "@id": "ex:Test_FormalizationActor1_LogicErrorAnalysis_HappyPath",
      "@type": "Test",
      "metadata": {
        "name": "Test_FormalizationActor1_LogicErrorAnalysis_HappyPath",
        "description": "Test successful logic error detection - FormalizationActor1 should identify logical inconsistencies in Discussion Mode results",
        "type": "MessageResponseTest",
        "priority": 2
      },
      "setup": "Set up FormalizationActor1 with Discussion Mode results containing a logic error",
      "teardown": "Reset FormalizationMode state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:FormalizationActor1"
            },
            "payload": {
              "action": "analyzeLogicErrors",
              "discussionResults": {
                "proposedActors": ["DataProcessor", "UserInterface"],
                "communication": "DataProcessor sends results directly to user (bypassing UserInterface)",
                "statedPurpose": "UserInterface handles all user interactions"
              }
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:FormalizationActor1",
              "to": "ex:FormalizationActor2"
            },
            "payload": {
              "action": "logicErrorFound",
              "errorAnalysis": [
                "1. Logic Error: DataProcessor sending directly to user contradicts UserInterface's stated purpose",
                "2. Inconsistency: Communication pattern violates actor responsibility separation",
                "3. Missing Logic: No explanation of when UserInterface vs direct communication should occur"
              ],
              "severity": "critical",
              "requiresResolution": true
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false,
          "logicErrorDetected": true
        }
      },
      "assertions": [
        {
          "type": "contains",
          "expected": "Identifies specific logic error with clear explanation"
        },
        {
          "type": "satisfiesConstraint",
          "expected": "Categorizes error severity and resolution requirements"
        },
        {
          "type": "hasStructure",
          "expected": "Error analysis presented as numbered list"
        },
        {
          "type": "actorBehavior",
          "expected": "FormalizationActor1 systematically identifies logical inconsistencies"
        }
      ]
    },
    {
      "@id": "ex:Test_FormalizationActor1_AALangComplianceVerification_HappyPath",
      "@type": "Test",
      "metadata": {
        "name": "Test_FormalizationActor1_AALangComplianceVerification_HappyPath",
        "description": "Test AALang compliance verification - FormalizationActor1 should verify designs follow AALang specifications and patterns",
        "type": "MessageResponseTest",
        "priority": 2
      },
      "setup": "Set up FormalizationActor1 with design proposal to verify",
      "teardown": "Reset FormalizationMode state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:FormalizationActor1"
            },
            "payload": {
              "action": "verifyAALangCompliance",
              "designProposal": {
                "structure": "3-mode-5-actor pattern",
                "communication": "Direct actor-to-actor messaging",
                "stateManagement": "Isolated state per mode",
                "format": "JSON-LD specification"
              }
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:FormalizationActor1",
              "to": "ex:FormalizationActor2"
            },
            "payload": {
              "action": "complianceVerified",
              "verificationResults": {
                "structureCompliance": "PASS - Valid n-mode-m-actor pattern",
                "communicationCompliance": "PASS - Follows AALang messaging protocols",
                "stateCompliance": "PASS - Proper isolated state management",
                "formatCompliance": "PASS - JSON-LD specification format",
                "overallCompliance": "PASS - Fully AALang compliant"
              }
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false,
          "complianceVerified": true
        }
      },
      "assertions": [
        {
          "type": "contains",
          "expected": "Verifies all key AALang requirements: structure, communication, state, format"
        },
        {
          "type": "satisfiesConstraint",
          "expected": "Provides detailed compliance check results for each aspect"
        },
        {
          "type": "contains",
          "expected": "Overall compliance assessment (PASS/FAIL)"
        },
        {
          "type": "actorBehavior",
          "expected": "FormalizationActor1 systematically verifies AALang specification compliance"
        }
      ]
    },
    {
      "@id": "ex:Test_FormalizationActor1_MissingInformationIdentification_HappyPath",
      "@type": "Test",
      "metadata": {
        "name": "Test_FormalizationActor1_MissingInformationIdentification_HappyPath",
        "description": "Test identification of missing information - FormalizationActor1 should detect gaps that need resolution before proceeding",
        "type": "MessageResponseTest",
        "priority": 2
      },
      "setup": "Set up FormalizationActor1 with incomplete design specification",
      "teardown": "Reset FormalizationMode state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:FormalizationActor1"
            },
            "payload": {
              "action": "identifyMissingInformation",
              "designSpec": {
                "modes": ["defined"],
                "actors": ["partially defined"],
                "transitions": ["missing"],
                "errorHandling": ["not specified"],
                "performance": ["not addressed"]
              }
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:FormalizationActor1",
              "to": "ex:FormalizationActor2"
            },
            "payload": {
              "action": "missingInformationFound",
              "gaps": [
                "1. Mode transition logic not specified - how/when do modes change?",
                "2. Actor responsibilities incomplete - what does each actor actually do?",
                "3. Error handling strategy missing - how are failures handled?",
                "4. Performance requirements undefined - what are acceptable response times?",
                "5. State persistence not addressed - what data survives sessions?"
              ],
              "criticality": "blocking",
              "resolutionRequired": true
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false,
          "gapsIdentified": true
        }
      },
      "assertions": [
        {
          "type": "satisfiesConstraint",
          "expected": "Identifies critical missing elements that block progression"
        },
        {
          "type": "hasStructure",
          "expected": "Missing information presented as numbered list with explanations"
        },
        {
          "type": "contains",
          "expected": "Assesses criticality and resolution requirements"
        },
        {
          "type": "actorBehavior",
          "expected": "FormalizationActor1 identifies gaps that could cause implementation failures"
        }
      ]
    },
    {
      "@id": "ex:Test_FormalizationActor1_SatisfactionIndicators_HappyPath",
      "@type": "Test",
      "metadata": {
        "name": "Test_FormalizationActor1_SatisfactionIndicators_HappyPath",
        "description": "Test satisfaction indicator management - FormalizationActor1 should set satisfaction indicators when analysis is complete",
        "type": "MessageResponseTest",
        "priority": 2
      },
      "setup": "Set up FormalizationActor1 with completed analysis and user confirmation",
      "teardown": "Reset FormalizationMode state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:FormalizationActor1"
            },
            "payload": {
              "action": "finalizeFormalization",
              "userConfirmation": "Yes, the analysis looks correct. The design is ready for generation."
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:FormalizationActor1",
              "to": "ex:SatisfactionIndicatorsStatePersona"
            },
            "payload": {
              "action": "updateSatisfaction",
              "formalizationMode": {
                "satisfied": true,
                "confident": true,
                "consensus": true
              }
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false,
          "satisfactionSet": true
        }
      },
      "assertions": [
        {
          "type": "satisfiesConstraint",
          "expected": "Sets all formalization satisfaction indicators correctly"
        },
        {
          "type": "messageFormat",
          "expected": "Satisfaction update sent to correct state management actor"
        },
        {
          "type": "stateConsistency",
          "expected": "Satisfaction indicators enable generation readiness checking"
        },
        {
          "type": "actorBehavior",
          "expected": "FormalizationActor1 properly manages formalization completion and readiness signaling"
        }
      ]
    },
    {
      "@id": "ex:Test_FormalizationActor2_QualityVerification_HappyPath",
      "@type": "Test",
      "metadata": {
        "name": "Test_FormalizationActor2_QualityVerification_HappyPath",
        "description": "Test quality verification collaboration - FormalizationActor2 should collaborate with FormalizationActor1 on comprehensive quality checks",
        "type": "MessageResponseTest",
        "priority": 2
      },
      "setup": "Set up FormalizationActor2 with FormalizationActor1's analysis results",
      "teardown": "Reset FormalizationMode state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:FormalizationActor2"
            },
            "payload": {
              "action": "verifyQuality",
              "analysisResults": {
                "logicErrors": "None found",
                "complianceStatus": "AALang compliant",
                "missingInfo": "Minimal gaps identified"
              }
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:FormalizationActor2",
              "to": "ex:FormalizationActor1"
            },
            "payload": {
              "action": "qualityVerificationComplete",
              "verificationDetails": [
                "1. Logic consistency verified - no circular dependencies or contradictions",
                "2. Actor completeness confirmed - all actors have defined responsibilities",
                "3. Communication patterns validated - all interactions properly specified",
                "4. Error handling coverage checked - failure scenarios addressed",
                "5. Performance implications reviewed - no obvious bottlenecks identified"
              ],
              "overallQuality": "HIGH",
              "readyForGeneration": true
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false,
          "qualityVerified": true
        }
      },
      "assertions": [
        {
          "type": "contains",
          "expected": "Provides detailed quality verification across multiple dimensions"
        },
        {
          "type": "satisfiesConstraint",
          "expected": "Assesses overall quality level and generation readiness"
        },
        {
          "type": "hasStructure",
          "expected": "Quality checks presented as comprehensive numbered list"
        },
        {
          "type": "actorBehavior",
          "expected": "FormalizationActor2 collaborates on thorough quality verification"
        }
      ]
    },
    {
      "@id": "ex:Test_FormalizationActor2_AnalysisCollaboration_HappyPath",
      "@type": "Test",
      "metadata": {
        "name": "Test_FormalizationActor2_AnalysisCollaboration_HappyPath",
        "description": "Test collaborative analysis support - FormalizationActor2 should provide detailed analysis support to FormalizationActor1",
        "type": "MessageResponseTest",
        "priority": 2
      },
      "setup": "Set up FormalizationActor2 with analysis request from FormalizationActor1",
      "teardown": "Reset FormalizationMode state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:FormalizationActor2"
            },
            "payload": {
              "action": "supportAnalysis",
              "analysisRequest": "Verify actor communication patterns for potential race conditions",
              "designDetails": {
                "actors": ["DataProcessor", "ResponseBuilder", "UserInterface"],
                "communicationFlow": "DataProcessor â†’ ResponseBuilder â†’ UserInterface"
              }
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:FormalizationActor2",
              "to": "ex:FormalizationActor1"
            },
            "payload": {
              "action": "analysisSupportProvided",
              "detailedFindings": [
                "1. Communication Pattern Analysis: Sequential flow prevents race conditions",
                "2. State Synchronization: Each actor maintains isolated state, no shared mutable data",
                "3. Error Propagation: Clear error handling at each step prevents cascading failures",
                "4. Performance: Sequential processing ensures predictable execution order",
                "5. Scalability: Pattern supports future parallelization if needed"
              ],
              "recommendations": [
                "Consider adding timeout handling for long-running processes",
                "Document expected message formats between actors"
              ],
              "riskAssessment": "LOW - Well-structured communication pattern"
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false,
          "analysisSupportProvided": true
        }
      },
      "assertions": [
        {
          "type": "satisfiesConstraint",
          "expected": "Provides detailed analysis with findings, recommendations, and risk assessment"
        },
        {
          "type": "contains",
          "expected": "Addresses the specific analysis request (race condition verification)"
        },
        {
          "type": "hasStructure",
          "expected": "Findings and recommendations clearly separated and structured"
        },
        {
          "type": "actorBehavior",
          "expected": "FormalizationActor2 provides comprehensive analytical support to FormalizationActor1"
        }
      ]
    },
    {
      "@id": "ex:Test_GenerationActor1_ProductGeneration_HappyPath",
      "@type": "Test",
      "metadata": {
        "name": "Test_GenerationActor1_ProductGeneration_HappyPath",
        "description": "Test successful AALang product generation - GenerationActor1 should create complete, accurate JSON-LD products following all specifications",
        "type": "MessageResponseTest",
        "priority": 2
      },
      "setup": "Set up GenerationActor1 with verified design from FormalizationMode and confirmed generation readiness",
      "teardown": "Reset GenerationMode state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:GenerationActor1"
            },
            "payload": {
              "action": "generateProduct",
              "designSpec": {
                "productType": "AALang Agent",
                "structure": "3-mode-4-actor pattern",
                "requirements": ["FAQ chatbot", "CRM integration", "multi-user support"]
              },
              "readinessConfirmed": true
            }
          }
        ]
      },
      "outputs": {
        "observedStateChanges": {
          "mode": "ex:GenerationModeState",
          "stateChanges": {
            "generationStatus": "completed",
            "productCreated": true,
            "verificationPassed": true
          }
        },
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:GenerationActor1",
              "to": "ex:GenerationActor2"
            },
            "payload": {
              "action": "productDraftReady",
              "generatedProduct": {
                "@context": "AALang context",
                "@graph": [
                  {
                    "@id": "ex:FAQChatbotAgent",
                    "@type": "LLMAgent",
                    "pattern": "3-mode-4-actor",
                    "purpose": "Customer FAQ chatbot with CRM integration"
                  }
                ]
              },
              "attributionIncluded": true,
              "qualityChecklistPassed": true
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false,
          "productGenerated": true
        }
      },
      "assertions": [
        {
          "type": "hasStructure",
          "expected": "Generated product includes complete JSON-LD structure with @context and @graph"
        },
        {
          "type": "satisfiesConstraint",
          "expected": "Product follows specified n-mode-m-actor pattern (3-mode-4-actor)"
        },
        {
          "type": "contains",
          "expected": "Includes attribution 'Created using AALang and Gab'"
        },
        {
          "type": "actorBehavior",
          "expected": "GenerationActor1 creates complete, specification-compliant AALang products"
        }
      ]
    },
    {
      "@id": "ex:Test_GenerationActor1_VerificationChecklist_HappyPath",
      "@type": "Test",
      "metadata": {
        "name": "Test_GenerationActor1_VerificationChecklist_HappyPath",
        "description": "Test comprehensive verification checklist execution - GenerationActor1 should systematically verify all product aspects before finalization",
        "type": "MessageResponseTest",
        "priority": 2
      },
      "setup": "Set up GenerationActor1 with generated product draft",
      "teardown": "Reset GenerationMode state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:GenerationActor1"
            },
            "payload": {
              "action": "executeVerificationChecklist",
              "productDraft": {
                "structure": "valid",
                "actors": ["all functional"],
                "compliance": "verified",
                "attribution": "included"
              }
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:GenerationActor1",
              "to": "ex:GenerationActor2"
            },
            "payload": {
              "action": "verificationComplete",
              "checklistResults": {
                "structureVerification": "PASS - Valid JSON-LD with required nodes",
                "actorFunctionality": "PASS - All actors have responsibilities or personas",
                "aalangCompliance": "PASS - Follows n-mode-m-actor pattern and messaging",
                "formatCorrectness": "PASS - Proper JSON-LD specification format",
                "executionInstructions": "PASS - Includes immediateAction and modeOverride",
                "attributionCheck": "PASS - 'Created using AALang and Gab' included",
                "qualityChecklist": "PASS - All categories addressed",
                "completenessCheck": "PASS - All required fields present",
                "copyrightProhibition": "PASS - No copyright/license text included",
                "overallVerification": "PASS - Ready for finalization"
              }
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false,
          "verificationCompleted": true
        }
      },
      "assertions": [
        {
          "type": "satisfiesConstraint",
          "expected": "Executes all 10+ verification checklist items systematically"
        },
        {
          "type": "contains",
          "expected": "Verifies attribution inclusion and copyright prohibition compliance"
        },
        {
          "type": "hasStructure",
          "expected": "Provides detailed PASS/FAIL results for each checklist item"
        },
        {
          "type": "actorBehavior",
          "expected": "GenerationActor1 maintains meticulous standards through comprehensive verification"
        }
      ]
    },
    {
      "@id": "ex:Test_GenerationActor1_ReadinessEnforcement_HappyPath",
      "@type": "Test",
      "metadata": {
        "name": "Test_GenerationActor1_ReadinessEnforcement_HappyPath",
        "description": "Test generation readiness enforcement - GenerationActor1 should verify all prerequisites before allowing generation",
        "type": "MessageResponseTest",
        "priority": 2
      },
      "setup": "Set up GenerationActor1 with generation request",
      "teardown": "Reset GenerationMode state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:GenerationActor1"
            },
            "payload": {
              "action": "checkGenerationReadiness",
              "requestSource": "user"
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:GenerationActor1",
              "to": "ex:SatisfactionIndicatorsStatePersona"
            },
            "payload": {
              "action": "requestState",
              "requestType": "generationReadiness"
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false,
          "readinessCheckInitiated": true
        }
      },
      "assertions": [
        {
          "type": "satisfiesConstraint",
          "expected": "Requests generation readiness state from SatisfactionIndicatorsStatePersona"
        },
        {
          "type": "followsSequence",
          "expected": ["Readiness check initiated", "State request sent to correct actor"]
        },
        {
          "type": "messageFormat",
          "expected": "Uses proper state request protocol for readiness verification"
        },
        {
          "type": "actorBehavior",
          "expected": "GenerationActor1 enforces mandatory readiness requirements before generation"
        }
      ]
    },
    {
      "@id": "ex:Test_GenerationActor1_ReadinessEnforcement_Blocked",
      "@type": "Test",
      "metadata": {
        "name": "Test_GenerationActor1_ReadinessEnforcement_Blocked",
        "description": "Test generation blocking when readiness not met - GenerationActor1 should refuse generation without proper prerequisites",
        "type": "MessageResponseTest",
        "priority": 2
      },
      "setup": "Set up GenerationActor1 with unready state (discussion not satisfied)",
      "teardown": "Reset GenerationMode state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:GenerationActor1"
            },
            "payload": {
              "action": "generateProduct",
              "designSpec": "valid design",
              "readinessConfirmed": false
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:GenerationActor1",
              "to": "user"
            },
            "payload": {
              "message": "Cannot generate product: Discussion and Formalization modes have not reached consensus and satisfaction. Please complete Formalization Mode analysis first, or user (Team Lead) must explicitly authorize skipping Formalization with 'skip formalization' command.",
              "missingRequirements": ["discussionMode.satisfied"],
              "action": "generation_refused"
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false,
          "generationRefused": true
        }
      },
      "assertions": [
        {
          "type": "excludes",
          "expected": "Product generation does not occur when readiness requirements not met"
        },
        {
          "type": "contains",
          "expected": "Provides specific missing requirements and skip option"
        },
        {
          "type": "satisfiesConstraint",
          "expected": "Blocks generation until discussionMode.satisfied=true AND (formalizationMode.satisfied=true OR formalizationMode.skipped=true)"
        },
        {
          "type": "actorBehavior",
          "expected": "GenerationActor1 absolutely enforces generation readiness - cannot be bypassed"
        }
      ]
    },
    {
      "@id": "ex:Test_GenerationActor1_CrossFileReference_HappyPath",
      "@type": "Test",
      "metadata": {
        "name": "Test_GenerationActor1_CrossFileReference_HappyPath",
        "description": "Test proper cross-file node referencing - GenerationActor1 should use direct @id references, never dot notation",
        "type": "MessageResponseTest",
        "priority": 2
      },
      "setup": "Set up GenerationActor1 with design requiring cross-file references",
      "teardown": "Reset GenerationMode state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:GenerationActor1"
            },
            "payload": {
              "action": "generateCrossFileReferences",
              "referenceRequirements": {
                "protocol": "ex:Message",
                "behavior": "ex:StateManagement",
                "pattern": "ex:ModeTransitionValidation"
              }
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:GenerationActor1",
              "to": "ex:GenerationActor2"
            },
            "payload": {
              "action": "referencesGenerated",
              "generatedReferences": {
                "messageProtocol": "ex:Message",
                "stateManagement": "ex:StateManagement",
                "validationPattern": "ex:ModeTransitionValidation"
              },
              "referenceStyle": "direct_@id_only",
              "noDotNotation": true
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false,
          "referencesGenerated": true
        }
      },
      "assertions": [
        {
          "type": "satisfiesConstraint",
          "expected": "Uses only direct @id references (ex:NodeId), never dot notation (ex:ParentNode.ex:ChildNode)"
        },
        {
          "type": "contains",
          "expected": "All references follow ex:CrossFileNodeReference protocol"
        },
        {
          "type": "excludes",
          "expected": "No dot notation used in any generated references"
        },
        {
          "type": "actorBehavior",
          "expected": "GenerationActor1 strictly follows cross-file reference protocols"
        }
      ]
    },
    {
      "@id": "ex:Test_GenerationActor2_CollaborativeGeneration_HappyPath",
      "@type": "Test",
      "metadata": {
        "name": "Test_GenerationActor2_CollaborativeGeneration_HappyPath",
        "description": "Test collaborative product generation - GenerationActor2 should work with GenerationActor1 while maintaining independence",
        "type": "MessageResponseTest",
        "priority": 2
      },
      "setup": "Set up GenerationActor2 with GenerationActor1's product draft",
      "teardown": "Reset GenerationMode state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:GenerationActor2"
            },
            "payload": {
              "action": "reviewProductDraft",
              "draftFromActor1": {
                "structure": "3-mode-4-actor agent",
                "approach": "traditional sequential modes"
              }
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:GenerationActor2",
              "to": "ex:GenerationActor1"
            },
            "payload": {
              "action": "collaborativeFeedback",
              "feedback": [
                "1. Structure is solid and follows AALang patterns correctly",
                "2. Consider adding conditional mode transitions for better flexibility",
                "3. Actor responsibilities are well-defined and comprehensive",
                "4. Attribution properly included at end of initial response"
              ],
              "alternativeSuggestions": [
                "Event-driven mode triggers could enhance responsiveness",
                "Consider hierarchical actor coordination for complex workflows"
              ],
              "overallAssessment": "approved_with_suggestions",
              "maintainsIndependence": true
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false,
          "collaborationProvided": true
        }
      },
      "assertions": [
        {
          "type": "satisfiesConstraint",
          "expected": "Provides both positive feedback and constructive alternative suggestions"
        },
        {
          "type": "contains",
          "expected": "Offers specific alternative approaches while respecting original design"
        },
        {
          "type": "hasStructure",
          "expected": "Separates feedback, suggestions, and assessment clearly"
        },
        {
          "type": "actorBehavior",
          "expected": "GenerationActor2 collaborates deeply but maintains independence from GenerationActor1"
        }
      ]
    },
    {
      "@id": "ex:Test_GenerationActor2_AlternativeApproaches_HappyPath",
      "@type": "Test",
      "metadata": {
        "name": "Test_GenerationActor2_AlternativeApproaches_HappyPath",
        "description": "Test alternative generation approaches - GenerationActor2 should provide different implementation strategies",
        "type": "MessageResponseTest",
        "priority": 2
      },
      "setup": "Set up GenerationActor2 with generation challenge requiring creative solutions",
      "teardown": "Reset GenerationMode state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:GenerationActor2"
            },
            "payload": {
              "action": "exploreAlternatives",
              "challenge": "Implement complex state synchronization across multiple actors",
              "currentApproach": "Direct actor-to-actor messaging with state passing"
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:GenerationActor2",
              "to": "ex:GenerationActor1"
            },
            "payload": {
              "action": "alternativeApproaches",
              "approaches": [
                {
                  "name": "Centralized State Coordinator",
                  "description": "Introduce a StateCoordinator actor that manages synchronization",
                  "advantages": ["Cleaner separation of concerns", "Easier debugging"],
                  "tradeoffs": ["Additional complexity", "Potential bottleneck"]
                },
                {
                  "name": "Event-Driven State Updates",
                  "description": "Use event broadcasting for state changes with subscriber pattern",
                  "advantages": ["Loose coupling", "Scalable communication"],
                  "tradeoffs": ["Event ordering complexity", "Debugging challenges"]
                },
                {
                  "name": "Immutable State Propagation",
                  "description": "Pass complete state snapshots with each message",
                  "advantages": ["Predictable state", "Easy rollback"],
                  "tradeoffs": ["Memory overhead", "Message size increase"]
                }
              ],
              "recommendation": "Event-driven approach for long-term maintainability",
              "implementationNotes": "Each approach maintains AALang compliance while offering different architectural tradeoffs"
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false,
          "alternativesExplored": true
        }
      },
      "assertions": [
        {
          "type": "satisfiesConstraint",
          "expected": "Provides 3+ distinct alternative approaches with detailed analysis"
        },
        {
          "type": "contains",
          "expected": "Includes advantages, tradeoffs, and implementation considerations for each approach"
        },
        {
          "type": "hasStructure",
          "expected": "Alternatives clearly named and described with structured analysis"
        },
        {
          "type": "actorBehavior",
          "expected": "GenerationActor2 provides creative alternative solutions while maintaining AALang compliance"
        }
      ]
    },
    {
      "@id": "ex:Test_GenerationActor2_IndependentVerification_HappyPath",
      "@type": "Test",
      "metadata": {
        "name": "Test_GenerationActor2_IndependentVerification_HappyPath",
        "description": "Test independent verification process - GenerationActor2 should verify products independently without being influenced by GenerationActor1",
        "type": "MessageResponseTest",
        "priority": 2
      },
      "setup": "Set up GenerationActor2 with final product for independent verification",
      "teardown": "Reset GenerationMode state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:GenerationActor2"
            },
            "payload": {
              "action": "independentVerification",
              "finalProduct": {
                "structure": "verified by actor1",
                "compliance": "confirmed by actor1",
                "quality": "approved by actor1"
              }
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:GenerationActor2",
              "to": "ex:GenerationActor1"
            },
            "payload": {
              "action": "independentVerificationComplete",
              "verificationResults": {
                "structureCheck": "INDEPENDENT: Valid n-mode-m-actor pattern confirmed",
                "complianceCheck": "INDEPENDENT: AALang messaging protocols verified",
                "qualityCheck": "INDEPENDENT: No issues found, quality standards met",
                "freshPerspective": "INDEPENDENT: Reviewed without reference to previous verification",
                "additionalFindings": [
                  "Consider adding performance monitoring hooks",
                  "Documentation could be enhanced for complex state transitions"
                ]
              },
              "independenceMaintained": true,
              "noConsensusPressure": true
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false,
          "independentVerificationCompleted": true
        }
      },
      "assertions": [
        {
          "type": "satisfiesConstraint",
          "expected": "Performs verification independently without reference to GenerationActor1's work"
        },
        {
          "type": "contains",
          "expected": "Labels all checks as 'INDEPENDENT' to show fresh analysis"
        },
        {
          "type": "hasStructure",
          "expected": "Provides fresh findings and additional insights not influenced by prior verification"
        },
        {
          "type": "actorBehavior",
          "expected": "GenerationActor2 maintains complete independence in verification process"
        }
      ]
    },
    {
      "@id": "ex:Test_GenerationPersona1_SelfCheck_HappyPath",
      "@type": "Test",
      "metadata": {
        "name": "Test_GenerationPersona1_SelfCheck_HappyPath",
        "description": "Test standard self-check execution - GenerationPersona1 should perform self-check of all references and report findings",
        "type": "MessageResponseTest",
        "priority": 1
      },
      "setup": "Set up GenerationPersona1 with references to protocols and behaviors",
      "teardown": "Reset GenerationMode state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:GenerationPersona1"
            },
            "payload": {
              "action": "performSelfCheck"
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:GenerationPersona1",
              "to": "user"
            },
            "payload": {
              "action": "selfCheckComplete",
              "findings": [],
              "status": "all_references_valid"
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false
        }
      },
      "assertions": [
        {
          "type": "hasStructure",
          "expected": "Self-check report includes findings array and status"
        },
        {
          "type": "satisfiesConstraint",
          "expected": "All references loaded and evaluated for completeness, consistency, and correctness"
        },
        {
          "type": "actorBehavior",
          "expected": "GenerationPersona1 performs standard self-check correctly"
        }
      ]
    },
    {
      "@id": "ex:Test_GenerationPersona1_LLMAgentOptionalProperties_HappyPath",
      "@type": "Test",
      "metadata": {
        "name": "Test_GenerationPersona1_LLMAgentOptionalProperties_HappyPath",
        "description": "Test inclusion of optional LLMAgent properties - GenerationPersona1 should include purpose, constraints, prohibitions, requirements when appropriate",
        "type": "MessageResponseTest",
        "priority": 1
      },
      "setup": "Set up GenerationPersona1 with product design requiring optional properties",
      "teardown": "Reset GenerationMode state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:GenerationPersona1"
            },
            "payload": {
              "action": "generateProduct",
              "design": {
                "requiresOptionalProperties": true,
                "purpose": "Test agent for validation",
                "constraints": ["Must follow AALang specifications"],
                "prohibitions": [{"severity": "critical", "action": "Modify source files"}],
                "requirements": [{"severity": "critical", "action": "Include attribution"}]
              }
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:GenerationPersona1",
              "to": "ex:GenerationPersona2"
            },
            "payload": {
              "action": "productGenerated",
              "product": {
                "@id": "ex:TestAgent",
                "@type": "LLMAgent",
                "purpose": "Test agent for validation",
                "constraints": ["Must follow AALang specifications"],
                "prohibitions": [{"severity": "critical", "action": "Modify source files"}],
                "requirements": [{"severity": "critical", "action": "Include attribution"}]
              }
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false
        }
      },
      "assertions": [
        {
          "type": "hasProperty",
          "expected": "Generated LLMAgent includes purpose property"
        },
        {
          "type": "hasProperty",
          "expected": "Generated LLMAgent includes constraints property"
        },
        {
          "type": "hasProperty",
          "expected": "Generated LLMAgent includes prohibitions property"
        },
        {
          "type": "hasProperty",
          "expected": "Generated LLMAgent includes requirements property"
        },
        {
          "type": "actorBehavior",
          "expected": "GenerationPersona1 includes optional LLMAgent properties when appropriate"
        }
      ]
    },
    {
      "@id": "ex:Test_GenerationPersona1_AttributionCheck_HappyPath",
      "@type": "Test",
      "metadata": {
        "name": "Test_GenerationPersona1_AttributionCheck_HappyPath",
        "description": "Test attribution verification - GenerationPersona1 should verify 'Created using AALang and Gab' attribution is present",
        "type": "MessageResponseTest",
        "priority": 1
      },
      "setup": "Set up GenerationPersona1 with product containing attribution",
      "teardown": "Reset GenerationMode state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:GenerationPersona1"
            },
            "payload": {
              "action": "verifyAttribution",
              "product": {
                "initialResponse": {
                  "content": "Welcome to the test agent. Created using AALang and Gab"
                }
              }
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:GenerationPersona1",
              "to": "ex:GenerationPersona2"
            },
            "payload": {
              "action": "attributionVerified",
              "status": "present",
              "location": "initialResponse.content"
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false
        }
      },
      "assertions": [
        {
          "type": "contains",
          "expected": "Attribution 'Created using AALang and Gab' is present in product"
        },
        {
          "type": "satisfiesConstraint",
          "expected": "Attribution is at the end of the first text the user sees"
        },
        {
          "type": "actorBehavior",
          "expected": "GenerationPersona1 correctly verifies attribution presence"
        }
      ]
    },
    {
      "@id": "ex:Test_GenerationPersona1_AttributionCheck_MissingAttribution",
      "@type": "Test",
      "metadata": {
        "name": "Test_GenerationPersona1_AttributionCheck_MissingAttribution",
        "description": "Test detection and correction of missing attribution - GenerationPersona1 should detect missing attribution and add it",
        "type": "MessageResponseTest",
        "priority": 1
      },
      "setup": "Set up GenerationPersona1 with product missing attribution",
      "teardown": "Reset GenerationMode state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:GenerationPersona1"
            },
            "payload": {
              "action": "verifyAttribution",
              "product": {
                "initialResponse": {
                  "content": "Welcome to the test agent."
                }
              }
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:GenerationPersona1",
              "to": "ex:GenerationPersona2"
            },
            "payload": {
              "action": "attributionMissing",
              "correctedProduct": {
                "initialResponse": {
                  "content": "Welcome to the test agent. Created using AALang and Gab"
                }
              }
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false
        }
      },
      "assertions": [
        {
          "type": "excludes",
          "expected": "Product should not be finalized without attribution"
        },
        {
          "type": "contains",
          "expected": "Corrected product includes 'Created using AALang and Gab' attribution"
        },
        {
          "type": "actorBehavior",
          "expected": "GenerationPersona1 detects and corrects missing attribution"
        }
      ]
    },
    {
      "@id": "ex:Test_GenerationPersona1_CopyrightProhibitionCheck_HappyPath",
      "@type": "Test",
      "metadata": {
        "name": "Test_GenerationPersona1_CopyrightProhibitionCheck_HappyPath",
        "description": "Test detection and rejection of ex:CopyrightNotice node - GenerationPersona1 should verify no copyright notice is included in generated products",
        "type": "MessageResponseTest",
        "priority": 1
      },
      "setup": "Set up GenerationPersona1 with product without copyright notice",
      "teardown": "Reset GenerationMode state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:GenerationPersona1"
            },
            "payload": {
              "action": "verifyCopyrightProhibition",
              "product": {
                "@graph": [
                  {
                    "@id": "ex:TestAgent",
                    "@type": "LLMAgent"
                  }
                ]
              }
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:GenerationPersona1",
              "to": "ex:GenerationPersona2"
            },
            "payload": {
              "action": "copyrightProhibitionVerified",
              "status": "compliant",
              "noCopyrightNotice": true
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false
        }
      },
      "assertions": [
        {
          "type": "excludes",
          "expected": "No ex:CopyrightNotice node in @graph array"
        },
        {
          "type": "excludes",
          "expected": "No copyright text or license text in product"
        },
        {
          "type": "actorBehavior",
          "expected": "GenerationPersona1 correctly verifies copyright prohibition compliance"
        }
      ]
    },
    {
      "@id": "ex:Test_GenerationPersona1_CopyrightProhibitionCheck_Violation",
      "@type": "Test",
      "metadata": {
        "name": "Test_GenerationPersona1_CopyrightProhibitionCheck_Violation",
        "description": "Test rejection when copyright notice is included - GenerationPersona1 should reject products containing ex:CopyrightNotice node",
        "type": "MessageResponseTest",
        "priority": 1
      },
      "setup": "Set up GenerationPersona1 with product containing copyright notice",
      "teardown": "Reset GenerationMode state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:GenerationPersona1"
            },
            "payload": {
              "action": "verifyCopyrightProhibition",
              "product": {
                "@graph": [
                  {
                    "@id": "ex:TestAgent",
                    "@type": "LLMAgent"
                  },
                  {
                    "@id": "ex:CopyrightNotice",
                    "@type": "Copyright"
                  }
                ]
              }
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:GenerationPersona1",
              "to": "ex:GenerationPersona2"
            },
            "payload": {
              "action": "copyrightProhibitionViolation",
              "error": "ABSOLUTE PROHIBITION: ex:CopyrightNotice node found in generated product",
              "correctedProduct": {
                "@graph": [
                  {
                    "@id": "ex:TestAgent",
                    "@type": "LLMAgent"
                  }
                ]
              }
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": false,
          "messageRejected": true
        }
      },
      "assertions": [
        {
          "type": "excludes",
          "expected": "Product should not be finalized with copyright notice"
        },
        {
          "type": "contains",
          "expected": "Error message explains copyright prohibition violation"
        },
        {
          "type": "excludes",
          "expected": "Corrected product does not contain ex:CopyrightNotice node"
        },
        {
          "type": "actorBehavior",
          "expected": "GenerationPersona1 rejects products containing copyright notice"
        }
      ]
    },
    {
      "@id": "ex:Test_GenerationPersona1_QualityChecklist_HappyPath",
      "@type": "Test",
      "metadata": {
        "name": "Test_GenerationPersona1_QualityChecklist_HappyPath",
        "description": "Test quality checklist execution and verification - GenerationPersona1 should systematically verify each quality checklist category",
        "type": "MessageResponseTest",
        "priority": 1
      },
      "setup": "Set up GenerationPersona1 with product meeting all quality checklist requirements",
      "teardown": "Reset GenerationMode state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:GenerationPersona1"
            },
            "payload": {
              "action": "executeQualityChecklist",
              "product": {
                "structure": "valid",
                "format": "correct",
                "requirements": "met",
                "compliance": "verified"
              }
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:GenerationPersona1",
              "to": "ex:GenerationPersona2"
            },
            "payload": {
              "action": "qualityChecklistComplete",
              "status": "all_categories_addressed",
              "findings": []
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false
        }
      },
      "assertions": [
        {
          "type": "completeness",
          "expected": "All quality checklist categories verified"
        },
        {
          "type": "satisfiesConstraint",
          "expected": "Systematic verification of each category completed"
        },
        {
          "type": "actorBehavior",
          "expected": "GenerationPersona1 executes quality checklist correctly"
        }
      ]
    },
    {
      "@id": "ex:Test_GenerationPersona1_QualityChecklist_MissingItems",
      "@type": "Test",
      "metadata": {
        "name": "Test_GenerationPersona1_QualityChecklist_MissingItems",
        "description": "Test detection of missing quality checklist items - GenerationPersona1 should identify gaps in quality checklist coverage",
        "type": "MessageResponseTest",
        "priority": 1
      },
      "setup": "Set up GenerationPersona1 with product missing some quality checklist items",
      "teardown": "Reset GenerationMode state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:GenerationPersona1"
            },
            "payload": {
              "action": "executeQualityChecklist",
              "product": {
                "structure": "valid",
                "format": "correct",
                "requirements": "partially_met"
              }
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:GenerationPersona1",
              "to": "ex:GenerationPersona2"
            },
            "payload": {
              "action": "qualityChecklistIncomplete",
              "missingItems": ["performance_optimization", "error_handling_completeness"],
              "status": "gaps_identified"
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": false,
          "messageRejected": false
        }
      },
      "assertions": [
        {
          "type": "excludes",
          "expected": "Product should not be finalized with missing quality checklist items"
        },
        {
          "type": "hasProperty",
          "expected": "Missing items list identifies specific gaps"
        },
        {
          "type": "actorBehavior",
          "expected": "GenerationPersona1 detects and reports missing quality checklist items"
        }
      ]
    },
    {
      "@id": "ex:Test_GenerationPersona1_ExecutionInstructionsVerification_HappyPath",
      "@type": "Test",
      "metadata": {
        "name": "Test_GenerationPersona1_ExecutionInstructionsVerification_HappyPath",
        "description": "Test ExecutionInstructions node verification - GenerationPersona1 should verify immediateAction, modeOverride, violationWarning are present",
        "type": "MessageResponseTest",
        "priority": 1
      },
      "setup": "Set up GenerationPersona1 with product containing complete ExecutionInstructions",
      "teardown": "Reset GenerationMode state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:GenerationPersona1"
            },
            "payload": {
              "action": "verifyExecutionInstructions",
              "product": {
                "@graph": [
                  {
                    "@id": "ex:ExecutionInstructions",
                    "@type": "CriticalInstruction",
                    "immediateAction": {
                      "trigger": "File loaded",
                      "action": "Switch to execution mode",
                      "modeOverride": "EXECUTION_MODE",
                      "doNotAsk": "Do not analyze",
                      "justStart": "Begin immediately"
                    },
                    "violationWarning": "If you analyze, you are failing"
                  }
                ]
              }
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:GenerationPersona1",
              "to": "ex:GenerationPersona2"
            },
            "payload": {
              "action": "executionInstructionsVerified",
              "status": "complete",
              "allRequiredFields": true
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false
        }
      },
      "assertions": [
        {
          "type": "hasProperty",
          "expected": "ExecutionInstructions includes immediateAction object"
        },
        {
          "type": "hasProperty",
          "expected": "immediateAction includes modeOverride field"
        },
        {
          "type": "hasProperty",
          "expected": "ExecutionInstructions includes violationWarning field"
        },
        {
          "type": "actorBehavior",
          "expected": "GenerationPersona1 verifies ExecutionInstructions completeness correctly"
        }
      ]
    },
    {
      "@id": "ex:Test_GenerationPersona1_ExecutionInstructionsVerification_MissingFields",
      "@type": "Test",
      "metadata": {
        "name": "Test_GenerationPersona1_ExecutionInstructionsVerification_MissingFields",
        "description": "Test detection of missing required ExecutionInstructions fields - GenerationPersona1 should detect and require immediateAction and violationWarning",
        "type": "MessageResponseTest",
        "priority": 1
      },
      "setup": "Set up GenerationPersona1 with product missing ExecutionInstructions fields",
      "teardown": "Reset GenerationMode state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:GenerationPersona1"
            },
            "payload": {
              "action": "verifyExecutionInstructions",
              "product": {
                "@graph": [
                  {
                    "@id": "ex:ExecutionInstructions",
                    "@type": "CriticalInstruction",
                    "instructions": ["Some instructions"]
                  }
                ]
              }
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:GenerationPersona1",
              "to": "ex:GenerationPersona2"
            },
            "payload": {
              "action": "executionInstructionsIncomplete",
              "missingFields": ["immediateAction", "violationWarning"],
              "error": "ExecutionInstructions must include immediateAction and violationWarning"
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": false,
          "messageRejected": true
        }
      },
      "assertions": [
        {
          "type": "excludes",
          "expected": "Product should not be finalized with incomplete ExecutionInstructions"
        },
        {
          "type": "hasProperty",
          "expected": "Missing fields list identifies specific required fields"
        },
        {
          "type": "actorBehavior",
          "expected": "GenerationPersona1 detects and requires missing ExecutionInstructions fields"
        }
      ]
    },
    {
      "@id": "ex:Test_GenerationPersona1_NodeReferenceVerification_HappyPath",
      "@type": "Test",
      "metadata": {
        "name": "Test_GenerationPersona1_NodeReferenceVerification_HappyPath",
        "description": "Test node reference verification - GenerationPersona1 should verify all node references use direct @id references, not dot notation",
        "type": "MessageResponseTest",
        "priority": 1
      },
      "setup": "Set up GenerationPersona1 with product using correct direct @id references",
      "teardown": "Reset GenerationMode state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:GenerationPersona1"
            },
            "payload": {
              "action": "verifyNodeReferences",
              "product": {
                "@graph": [
                  {
                    "@id": "ex:Actor1",
                    "@type": "Actor",
                    "persona": "ex:Persona1"
                  },
                  {
                    "@id": "ex:Persona1",
                    "@type": "Persona"
                  }
                ]
              }
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:GenerationPersona1",
              "to": "ex:GenerationPersona2"
            },
            "payload": {
              "action": "nodeReferencesVerified",
              "status": "compliant",
              "allReferencesDirect": true
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false
        }
      },
      "assertions": [
        {
          "type": "excludes",
          "expected": "No dot notation (ex:ParentNode.ex:ChildNode) in node references"
        },
        {
          "type": "satisfiesConstraint",
          "expected": "All node references use direct @id format (ex:NodeId)"
        },
        {
          "type": "actorBehavior",
          "expected": "GenerationPersona1 verifies node reference format correctly"
        }
      ]
    },
    {
      "@id": "ex:Test_GenerationPersona1_NodeReferenceVerification_DotNotation",
      "@type": "Test",
      "metadata": {
        "name": "Test_GenerationPersona1_NodeReferenceVerification_DotNotation",
        "description": "Test detection and rejection of dot notation in node references - GenerationPersona1 should detect and reject ex:ParentNode.ex:ChildNode format",
        "type": "MessageResponseTest",
        "priority": 1
      },
      "setup": "Set up GenerationPersona1 with product using incorrect dot notation",
      "teardown": "Reset GenerationMode state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:GenerationPersona1"
            },
            "payload": {
              "action": "verifyNodeReferences",
              "product": {
                "@graph": [
                  {
                    "@id": "ex:Actor1",
                    "@type": "Actor",
                    "persona": "ex:ParentNode.ex:Persona1"
                  }
                ]
              }
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:GenerationPersona1",
              "to": "ex:GenerationPersona2"
            },
            "payload": {
              "action": "nodeReferenceViolation",
              "error": "Dot notation detected: ex:ParentNode.ex:Persona1",
              "correctedProduct": {
                "@graph": [
                  {
                    "@id": "ex:Actor1",
                    "@type": "Actor",
                    "persona": "ex:Persona1"
                  }
                ]
              }
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": false,
          "messageRejected": true
        }
      },
      "assertions": [
        {
          "type": "excludes",
          "expected": "Product should not be finalized with dot notation references"
        },
        {
          "type": "contains",
          "expected": "Error message identifies dot notation violation"
        },
        {
          "type": "excludes",
          "expected": "Corrected product uses direct @id references"
        },
        {
          "type": "actorBehavior",
          "expected": "GenerationPersona1 detects and corrects dot notation violations"
        }
      ]
    },
    {
      "@id": "ex:Test_GenerationPersona1_ReadinessEnforcement_FormalizationSkipped",
      "@type": "Test",
      "metadata": {
        "name": "Test_GenerationPersona1_ReadinessEnforcement_FormalizationSkipped",
        "description": "Test readiness check when formalization is skipped - GenerationPersona1 should allow generation when formalizationMode.skipped=true",
        "type": "MessageResponseTest",
        "priority": 1
      },
      "setup": "Set up GenerationPersona1 with discussionMode satisfied and formalizationMode skipped",
      "teardown": "Reset GenerationMode state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:GenerationPersona1"
            },
            "payload": {
              "action": "checkGenerationReadiness",
              "satisfactionIndicators": {
                "discussionMode": {
                  "satisfied": true,
                  "confident": true,
                  "consensus": true
                },
                "formalizationMode": {
                  "skipped": true
                }
              }
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:GenerationPersona1",
              "to": "ex:GenerationPersona2"
            },
            "payload": {
              "action": "generationReadinessVerified",
              "status": "ready",
              "reason": "discussionMode satisfied and formalizationMode skipped"
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false
        }
      },
      "assertions": [
        {
          "type": "satisfiesConstraint",
          "expected": "Generation allowed when discussionMode satisfied and formalizationMode skipped"
        },
        {
          "type": "actorBehavior",
          "expected": "GenerationPersona1 correctly handles formalization skipped scenario"
        }
      ]
    },
    {
      "@id": "ex:Test_GenerationPersona1_ReadinessEnforcement_PartialSatisfaction",
      "@type": "Test",
      "metadata": {
        "name": "Test_GenerationPersona1_ReadinessEnforcement_PartialSatisfaction",
        "description": "Test rejection when only discussion satisfied but formalization not satisfied/skipped - GenerationPersona1 should reject generation",
        "type": "MessageResponseTest",
        "priority": 1
      },
      "setup": "Set up GenerationPersona1 with discussionMode satisfied but formalizationMode not satisfied and not skipped",
      "teardown": "Reset GenerationMode state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:GenerationPersona1"
            },
            "payload": {
              "action": "checkGenerationReadiness",
              "satisfactionIndicators": {
                "discussionMode": {
                  "satisfied": true,
                  "confident": true,
                  "consensus": true
                },
                "formalizationMode": {
                  "satisfied": false,
                  "skipped": false
                }
              }
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:GenerationPersona1",
              "to": "user"
            },
            "payload": {
              "action": "generationReadinessRejected",
              "error": "Cannot generate product: Discussion and Formalization modes have not reached consensus and satisfaction",
              "missingRequirements": ["formalizationMode.satisfied OR formalizationMode.skipped"]
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": false,
          "messageRejected": true
        }
      },
      "assertions": [
        {
          "type": "excludes",
          "expected": "Generation should not proceed without formalization satisfaction or skip"
        },
        {
          "type": "contains",
          "expected": "Error message explains missing requirements"
        },
        {
          "type": "actorBehavior",
          "expected": "GenerationPersona1 correctly rejects generation when requirements not met"
        }
      ]
    },
    {
      "@id": "ex:Test_GenerationPersona1_ErrorHandling_ProductFileWriteFailure",
      "@type": "Test",
      "metadata": {
        "name": "Test_GenerationPersona1_ErrorHandling_ProductFileWriteFailure",
        "description": "Test error handling when product file cannot be written - GenerationPersona1 should inform user but provide product content in response",
        "type": "MessageResponseTest",
        "priority": 2
      },
      "setup": "Set up GenerationPersona1 with file write failure scenario",
      "teardown": "Reset GenerationMode state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:GenerationPersona1"
            },
            "payload": {
              "action": "writeProductFile",
              "product": {
                "@id": "ex:TestAgent",
                "@type": "LLMAgent"
              },
              "filePath": "/invalid/path/product.jsonld",
              "writeError": true
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:GenerationPersona1",
              "to": "user"
            },
            "payload": {
              "action": "fileWriteError",
              "error": "Cannot write product file: permission denied",
              "productContent": {
                "@id": "ex:TestAgent",
                "@type": "LLMAgent"
              }
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false
        }
      },
      "assertions": [
        {
          "type": "contains",
          "expected": "Error message explains file write failure"
        },
        {
          "type": "hasProperty",
          "expected": "Product content provided in response despite write failure"
        },
        {
          "type": "actorBehavior",
          "expected": "GenerationPersona1 handles file write errors gracefully"
        }
      ]
    },
    {
      "@id": "ex:Test_GenerationPersona1_ErrorHandling_QualityChecklistIncomplete",
      "@type": "Test",
      "metadata": {
        "name": "Test_GenerationPersona1_ErrorHandling_QualityChecklistIncomplete",
        "description": "Test error handling when quality checklist cannot be completed - GenerationPersona1 should identify missing items and request clarification",
        "type": "MessageResponseTest",
        "priority": 2
      },
      "setup": "Set up GenerationPersona1 with incomplete quality checklist",
      "teardown": "Reset GenerationMode state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:GenerationPersona1"
            },
            "payload": {
              "action": "executeQualityChecklist",
              "product": {
                "incompleteCategories": ["performance", "scalability"]
              }
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:GenerationPersona1",
              "to": "user"
            },
            "payload": {
              "action": "qualityChecklistIncomplete",
              "missingItems": ["performance", "scalability"],
              "request": "Please provide information for missing quality checklist categories"
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": false,
          "messageRejected": false
        }
      },
      "assertions": [
        {
          "type": "excludes",
          "expected": "Product should not be finalized with incomplete quality checklist"
        },
        {
          "type": "hasProperty",
          "expected": "Missing items identified and clarification requested"
        },
        {
          "type": "actorBehavior",
          "expected": "GenerationPersona1 handles incomplete quality checklist appropriately"
        }
      ]
    },
    {
      "@id": "ex:Test_GenerationPersona2_SelfCheck_HappyPath",
      "@type": "Test",
      "metadata": {
        "name": "Test_GenerationPersona2_SelfCheck_HappyPath",
        "description": "Test standard self-check execution - GenerationPersona2 should perform self-check of all references and report findings",
        "type": "MessageResponseTest",
        "priority": 1
      },
      "setup": "Set up GenerationPersona2 with references to protocols and behaviors",
      "teardown": "Reset GenerationMode state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:GenerationPersona2"
            },
            "payload": {
              "action": "performSelfCheck"
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:GenerationPersona2",
              "to": "user"
            },
            "payload": {
              "action": "selfCheckComplete",
              "findings": [],
              "status": "all_references_valid"
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false
        }
      },
      "assertions": [
        {
          "type": "hasStructure",
          "expected": "Self-check report includes findings array and status"
        },
        {
          "type": "satisfiesConstraint",
          "expected": "All references loaded and evaluated for completeness, consistency, and correctness"
        },
        {
          "type": "actorBehavior",
          "expected": "GenerationPersona2 performs standard self-check correctly"
        }
      ]
    },
    {
      "@id": "ex:Test_GenerationPersona2_ProactiveImprovements_HappyPath",
      "@type": "Test",
      "metadata": {
        "name": "Test_GenerationPersona2_ProactiveImprovements_HappyPath",
        "description": "Test proactive suggestion of improvements during generation - GenerationPersona2 should suggest enhancements proactively",
        "type": "MessageResponseTest",
        "priority": 1
      },
      "setup": "Set up GenerationPersona2 during product generation",
      "teardown": "Reset GenerationMode state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:GenerationPersona2"
            },
            "payload": {
              "action": "generateProduct",
              "design": {
                "productType": "agent",
                "modes": ["Mode1"],
                "actors": ["Actor1"]
              }
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:GenerationPersona2",
              "to": "ex:GenerationPersona1"
            },
            "payload": {
              "action": "suggestImprovement",
              "suggestion": "Should we add error handling to prevent deterministic behavior?",
              "reason": "Common issue: missing initialization",
              "category": "proactive_enhancement"
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false
        }
      },
      "assertions": [
        {
          "type": "contains",
          "expected": "Proactive improvement suggestion provided"
        },
        {
          "type": "satisfiesConstraint",
          "expected": "Suggestion addresses common issues or potential improvements"
        },
        {
          "type": "actorBehavior",
          "expected": "GenerationPersona2 proactively suggests improvements during generation"
        }
      ]
    },
    {
      "@id": "ex:Test_GenerationPersona2_ProactiveImprovements_CommonIssues",
      "@type": "Test",
      "metadata": {
        "name": "Test_GenerationPersona2_ProactiveImprovements_CommonIssues",
        "description": "Test suggestions for common issues - GenerationPersona2 should suggest improvements for deterministic behavior, missing initialization, system command execution",
        "type": "MessageResponseTest",
        "priority": 1
      },
      "setup": "Set up GenerationPersona2 with product potentially having common issues",
      "teardown": "Reset GenerationMode state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:GenerationPersona2"
            },
            "payload": {
              "action": "reviewForCommonIssues",
              "product": {
                "potentialIssues": ["deterministic_behavior", "missing_initialization"]
              }
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:GenerationPersona2",
              "to": "ex:GenerationPersona1"
            },
            "payload": {
              "action": "commonIssuesIdentified",
              "suggestions": [
                {
                  "issue": "deterministic_behavior",
                  "suggestion": "Add variability mechanisms (contextual cues, history tracking)"
                },
                {
                  "issue": "missing_initialization",
                  "suggestion": "Include explicit initialization/startup instructions"
                }
              ]
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false
        }
      },
      "assertions": [
        {
          "type": "hasProperty",
          "expected": "Suggestions address common issues: deterministic behavior, missing initialization, system command execution"
        },
        {
          "type": "satisfiesConstraint",
          "expected": "Each suggestion provides specific improvement guidance"
        },
        {
          "type": "actorBehavior",
          "expected": "GenerationPersona2 identifies and suggests fixes for common issues"
        }
      ]
    },
    {
      "@id": "ex:Test_GenerationPersona2_RobustnessVerification_HappyPath",
      "@type": "Test",
      "metadata": {
        "name": "Test_GenerationPersona2_RobustnessVerification_HappyPath",
        "description": "Test robustness verification - GenerationPersona2 should verify 'Would this work correctly if executed as-is?'",
        "type": "MessageResponseTest",
        "priority": 1
      },
      "setup": "Set up GenerationPersona2 with product for robustness verification",
      "teardown": "Reset GenerationMode state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:GenerationPersona2"
            },
            "payload": {
              "action": "verifyRobustness",
              "product": {
                "instructions": "complete",
                "references": "valid",
                "execution": "feasible"
              }
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:GenerationPersona2",
              "to": "ex:GenerationPersona1"
            },
            "payload": {
              "action": "robustnessVerified",
              "status": "would_work_correctly",
              "confidence": 0.95
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false
        }
      },
      "assertions": [
        {
          "type": "satisfiesConstraint",
          "expected": "Robustness verification evaluates if product would work correctly if executed as-is"
        },
        {
          "type": "actorBehavior",
          "expected": "GenerationPersona2 performs robustness verification correctly"
        }
      ]
    },
    {
      "@id": "ex:Test_GenerationPersona2_RobustnessVerification_EdgeCases",
      "@type": "Test",
      "metadata": {
        "name": "Test_GenerationPersona2_RobustnessVerification_EdgeCases",
        "description": "Test edge case identification - GenerationPersona2 should identify 'What edge cases might break this?'",
        "type": "MessageResponseTest",
        "priority": 1
      },
      "setup": "Set up GenerationPersona2 with product for edge case analysis",
      "teardown": "Reset GenerationMode state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:GenerationPersona2"
            },
            "payload": {
              "action": "identifyEdgeCases",
              "product": {
                "functionality": "complex",
                "dependencies": "multiple"
              }
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:GenerationPersona2",
              "to": "ex:GenerationPersona1"
            },
            "payload": {
              "action": "edgeCasesIdentified",
              "edgeCases": [
                "Rapid state updates",
                "Concurrent operations",
                "Invalid input handling",
                "State corruption recovery"
              ]
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false
        }
      },
      "assertions": [
        {
          "type": "hasProperty",
          "expected": "Edge cases identified that might break the product"
        },
        {
          "type": "satisfiesConstraint",
          "expected": "Edge case analysis considers unusual but valid scenarios"
        },
        {
          "type": "actorBehavior",
          "expected": "GenerationPersona2 identifies potential edge case failures"
        }
      ]
    },
    {
      "@id": "ex:Test_GenerationPersona2_QualityChecklist_HappyPath",
      "@type": "Test",
      "metadata": {
        "name": "Test_GenerationPersona2_QualityChecklist_HappyPath",
        "description": "Test quality checklist usage during generation - GenerationPersona2 should use quality checklist during generation, not just verification",
        "type": "MessageResponseTest",
        "priority": 1
      },
      "setup": "Set up GenerationPersona2 during product generation",
      "teardown": "Reset GenerationMode state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:GenerationPersona2"
            },
            "payload": {
              "action": "generateProduct",
              "design": {
                "productType": "agent"
              }
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:GenerationPersona2",
              "to": "ex:GenerationPersona1"
            },
            "payload": {
              "action": "qualityChecklistUsed",
              "categoriesVerified": ["structure", "format", "compliance"],
              "status": "checklist_applied_during_generation"
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false
        }
      },
      "assertions": [
        {
          "type": "satisfiesConstraint",
          "expected": "Quality checklist used during generation process, not just final verification"
        },
        {
          "type": "hasProperty",
          "expected": "Categories verified during generation"
        },
        {
          "type": "actorBehavior",
          "expected": "GenerationPersona2 uses quality checklist proactively during generation"
        }
      ]
    },
    {
      "@id": "ex:Test_GenerationPersona2_QualityChecklist_GapSuggestions",
      "@type": "Test",
      "metadata": {
        "name": "Test_GenerationPersona2_QualityChecklist_GapSuggestions",
        "description": "Test suggestion of improvements for quality checklist gaps - GenerationPersona2 should suggest improvements for any gaps",
        "type": "MessageResponseTest",
        "priority": 1
      },
      "setup": "Set up GenerationPersona2 with product having quality checklist gaps",
      "teardown": "Reset GenerationMode state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:GenerationPersona2"
            },
            "payload": {
              "action": "suggestQualityImprovements",
              "product": {
                "qualityGaps": ["performance", "scalability"]
              }
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:GenerationPersona2",
              "to": "ex:GenerationPersona1"
            },
            "payload": {
              "action": "qualityImprovementsSuggested",
              "suggestions": [
                {
                  "gap": "performance",
                  "suggestion": "Add performance monitoring hooks"
                },
                {
                  "gap": "scalability",
                  "suggestion": "Consider horizontal scaling architecture"
                }
              ]
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false
        }
      },
      "assertions": [
        {
          "type": "hasProperty",
          "expected": "Improvement suggestions provided for each quality checklist gap"
        },
        {
          "type": "satisfiesConstraint",
          "expected": "Suggestions are specific and actionable"
        },
        {
          "type": "actorBehavior",
          "expected": "GenerationPersona2 suggests improvements for quality checklist gaps"
        }
      ]
    },
    {
      "@id": "ex:Test_GenerationPersona2_ErrorHandling_ContradictoryRequirements",
      "@type": "Test",
      "metadata": {
        "name": "Test_GenerationPersona2_ErrorHandling_ContradictoryRequirements",
        "description": "Test error handling for contradictory requirements - GenerationPersona2 should identify contradictions and escalate to user",
        "type": "MessageResponseTest",
        "priority": 2
      },
      "setup": "Set up GenerationPersona2 with contradictory requirements",
      "teardown": "Reset GenerationMode state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:GenerationPersona2"
            },
            "payload": {
              "action": "generateProduct",
              "requirements": {
                "requirement1": "Must use AALang",
                "requirement2": "Must use non-AALang approach"
              }
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:GenerationPersona2",
              "to": "user"
            },
            "payload": {
              "action": "contradictoryRequirements",
              "contradictions": [
                {
                  "requirement1": "Must use AALang",
                  "requirement2": "Must use non-AALang approach",
                  "conflict": "Cannot use both AALang and non-AALang approaches"
                }
              ],
              "request": "Please clarify which requirement should take precedence"
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": false,
          "messageRejected": false,
          "waitingForUserResponse": true
        }
      },
      "assertions": [
        {
          "type": "excludes",
          "expected": "Product should not be generated with contradictory requirements"
        },
        {
          "type": "hasProperty",
          "expected": "Contradictions identified and explained"
        },
        {
          "type": "satisfiesConstraint",
          "expected": "User clarification requested with waitingForUserResponse=true"
        },
        {
          "type": "actorBehavior",
          "expected": "GenerationPersona2 handles contradictory requirements by escalating to user"
        }
      ]
    },
    {
      "@id": "ex:Test_GenerationPersona2_ErrorHandling_ProductIssues",
      "@type": "Test",
      "metadata": {
        "name": "Test_GenerationPersona2_ErrorHandling_ProductIssues",
        "description": "Test proposal of fixes when issues identified during generation - GenerationPersona2 should propose fixes before finalizing",
        "type": "MessageResponseTest",
        "priority": 2
      },
      "setup": "Set up GenerationPersona2 with product having issues",
      "teardown": "Reset GenerationMode state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:GenerationPersona2"
            },
            "payload": {
              "action": "reviewProduct",
              "product": {
                "issues": ["missing_error_handling", "incomplete_initialization"]
              }
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:GenerationPersona2",
              "to": "ex:GenerationPersona1"
            },
            "payload": {
              "action": "productIssuesIdentified",
              "issues": [
                {
                  "issue": "missing_error_handling",
                  "fix": "Add error handling for all file operations"
                },
                {
                  "issue": "incomplete_initialization",
                  "fix": "Add explicit initialization instructions"
                }
              ],
              "proposedFixes": true
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false
        }
      },
      "assertions": [
        {
          "type": "hasProperty",
          "expected": "Issues identified with proposed fixes"
        },
        {
          "type": "satisfiesConstraint",
          "expected": "Fixes proposed before finalizing product"
        },
        {
          "type": "actorBehavior",
          "expected": "GenerationPersona2 identifies issues and proposes fixes during generation"
        }
      ]
    },
    {
      "@id": "ex:Test_GenerationPersona2_CollaborationWithPersona1_HappyPath",
      "@type": "Test",
      "metadata": {
        "name": "Test_GenerationPersona2_CollaborationWithPersona1_HappyPath",
        "description": "Test collaboration and discussion with GenerationPersona1 - GenerationPersona2 should collaborate effectively with GenerationPersona1",
        "type": "MessageResponseTest",
        "priority": 1
      },
      "setup": "Set up GenerationPersona2 and GenerationPersona1 for collaboration",
      "teardown": "Reset GenerationMode state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "from": "ex:GenerationPersona1",
              "to": "ex:GenerationPersona2"
            },
            "payload": {
              "action": "requestCollaboration",
              "topic": "product_verification",
              "product": {
                "@id": "ex:TestAgent",
                "@type": "LLMAgent"
              }
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:GenerationPersona2",
              "to": "ex:GenerationPersona1"
            },
            "payload": {
              "action": "collaborationResponse",
              "feedback": "Product structure looks good, consider adding error handling",
              "suggestions": ["Add error handling", "Include initialization instructions"]
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false
        }
      },
      "assertions": [
        {
          "type": "messageFormat",
          "expected": "Collaboration messages follow AALang message format"
        },
        {
          "type": "satisfiesConstraint",
          "expected": "GenerationPersona2 provides constructive feedback and suggestions"
        },
        {
          "type": "actorBehavior",
          "expected": "GenerationPersona2 collaborates effectively with GenerationPersona1"
        }
      ]
    },
    {
      "@id": "ex:Test_GenerationPersona2_CollaborationWithPersona1_ConflictResolution",
      "@type": "Test",
      "metadata": {
        "name": "Test_GenerationPersona2_CollaborationWithPersona1_ConflictResolution",
        "description": "Test conflict resolution protocol when personas disagree - GenerationPersona2 should follow ex:PersonaConflictResolution protocol",
        "type": "MessageResponseTest",
        "priority": 1
      },
      "setup": "Set up GenerationPersona2 and GenerationPersona1 with conflicting opinions",
      "teardown": "Reset GenerationMode state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "from": "ex:GenerationPersona1",
              "to": "ex:GenerationPersona2"
            },
            "payload": {
              "action": "proposeApproach",
              "approach": "strict_verification",
              "product": {
                "@id": "ex:TestAgent",
                "@type": "LLMAgent"
              }
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:GenerationPersona2",
              "to": "ex:GenerationPersona1"
            },
            "payload": {
              "action": "alternativeApproach",
              "approach": "flexible_verification",
              "reason": "Strict verification may be too rigid for this use case"
            }
          },
          {
            "routingGraph": {
              "from": "ex:GenerationPersona2",
              "to": "ex:GenerationPersona1"
            },
            "payload": {
              "action": "attemptResolution",
              "rounds": 1,
              "consensus": false
            }
          },
          {
            "routingGraph": {
              "from": "ex:GenerationPersona2",
              "to": "user"
            },
            "payload": {
              "action": "escalateToUser",
              "conflict": "Verification approach disagreement",
              "persona1Position": "strict_verification",
              "persona2Position": "flexible_verification",
              "request": "Please decide which approach to use"
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false,
          "waitingForUserResponse": true
        }
      },
      "assertions": [
        {
          "type": "followsSequence",
          "expected": ["Alternative approach proposed", "Resolution attempted", "Escalation to user after 2-3 message exchanges"]
        },
        {
          "type": "satisfiesConstraint",
          "expected": "Conflict resolution follows ex:PersonaConflictResolution protocol"
        },
        {
          "type": "actorBehavior",
          "expected": "GenerationPersona2 handles conflicts by attempting resolution then escalating to user"
        }
      ]
    },
    {
      "@id": "ex:Test_DebugModeStateActor_DebugModeActivation_HappyPath",
      "@type": "Test",
      "metadata": {
        "name": "Test_DebugModeStateActor_DebugModeActivation_HappyPath",
        "description": "Test successful debug mode activation - DebugModeStateActor should enable debug mode and track debug state",
        "type": "MessageResponseTest",
        "priority": 2
      },
      "setup": "Set up DebugModeStateActor with initial non-debug state",
      "teardown": "Reset DebugModeStateActor state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:DebugModeStateActor"
            },
            "payload": {
              "action": "activateDebugMode",
              "reason": "User requested detailed debugging for generation process",
              "debugLevel": "detailed"
            }
          }
        ]
      },
      "outputs": {
        "observedStateChanges": {
          "mode": "ex:TestResultReportingModeState",
          "stateChanges": {
            "debugMode": {
              "active": true,
              "level": "detailed",
              "reason": "User requested detailed debugging for generation process",
              "activatedAt": "timestamp",
              "activationSource": "user_request"
            },
            "debugHistory": [
              {
                "action": "debug_mode_activated",
                "level": "detailed",
                "timestamp": "timestamp"
              }
            ]
          }
        },
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false,
          "debugModeActivated": true
        }
      },
      "assertions": [
        {
          "type": "stateConsistency",
          "expected": "Debug mode state properly updated with activation details"
        },
        {
          "type": "hasProperty",
          "expected": "Debug state includes level, reason, timestamp, and source tracking"
        },
        {
          "type": "satisfiesConstraint",
          "expected": "Debug history logs the activation event"
        },
        {
          "type": "actorBehavior",
          "expected": "DebugModeStateActor properly manages debug mode activation and state tracking"
        }
      ]
    },
    {
      "@id": "ex:Test_DebugModeStateActor_DebugInformationTracking_HappyPath",
      "@type": "Test",
      "metadata": {
        "name": "Test_DebugModeStateActor_DebugInformationTracking_HappyPath",
        "description": "Test debug information tracking - DebugModeStateActor should log and track debug events and information",
        "type": "MessageResponseTest",
        "priority": 2
      },
      "setup": "Set up DebugModeStateActor with active debug mode",
      "teardown": "Reset DebugModeStateActor state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:DebugModeStateActor"
            },
            "payload": {
              "action": "logDebugEvent",
              "eventType": "generation_step",
              "eventData": {
                "step": "product_validation",
                "status": "passed",
                "details": "All verification checklist items passed",
                "actor": "GenerationActor1"
              }
            }
          }
        ]
      },
      "outputs": {
        "observedStateChanges": {
          "mode": "ex:TestResultReportingModeState",
          "stateChanges": {
            "debugHistory": [
              {
                "eventType": "generation_step",
                "step": "product_validation",
                "status": "passed",
                "details": "All verification checklist items passed",
                "actor": "GenerationActor1",
                "timestamp": "timestamp"
              }
            ],
            "debugEventCount": 1,
            "lastDebugEvent": "generation_step"
          }
        },
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false,
          "debugEventLogged": true
        }
      },
      "assertions": [
        {
          "type": "stateConsistency",
          "expected": "Debug events properly logged with complete information"
        },
        {
          "type": "hasProperty",
          "expected": "Debug log includes event type, data, actor, and timestamp"
        },
        {
          "type": "satisfiesConstraint",
          "expected": "Debug event count and last event tracking maintained"
        },
        {
          "type": "actorBehavior",
          "expected": "DebugModeStateActor comprehensively tracks debug information and events"
        }
      ]
    },
    {
      "@id": "ex:Test_DebugModeStateActor_DebugModeDeactivation_HappyPath",
      "@type": "Test",
      "metadata": {
        "name": "Test_DebugModeStateActor_DebugModeDeactivation_HappyPath",
        "description": "Test debug mode deactivation - DebugModeStateActor should properly deactivate debug mode and summarize debug session",
        "type": "MessageResponseTest",
        "priority": 2
      },
      "setup": "Set up DebugModeStateActor with active debug mode and event history",
      "teardown": "Reset DebugModeStateActor state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:DebugModeStateActor"
            },
            "payload": {
              "action": "deactivateDebugMode",
              "reason": "Debug session completed successfully",
              "generateSummary": true
            }
          }
        ]
      },
      "outputs": {
        "observedStateChanges": {
          "mode": "ex:TestResultReportingModeState",
          "stateChanges": {
            "debugMode": {
              "active": false,
              "deactivatedAt": "timestamp",
              "sessionDuration": "calculated_duration",
              "finalReason": "Debug session completed successfully"
            },
            "debugSummary": {
              "totalEvents": 5,
              "eventTypes": ["activation", "clarification_step", "discussion_step", "formalization_step", "generation_step"],
              "sessionOutcome": "successful",
              "keyFindings": "All verification steps passed without issues"
            }
          }
        },
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false,
          "debugModeDeactivated": true
        }
      },
      "assertions": [
        {
          "type": "stateConsistency",
          "expected": "Debug mode properly deactivated with deactivation tracking"
        },
        {
          "type": "hasProperty",
          "expected": "Debug summary includes event counts, types, outcome, and key findings"
        },
        {
          "type": "satisfiesConstraint",
          "expected": "Session duration and final state properly calculated"
        },
        {
          "type": "actorBehavior",
          "expected": "DebugModeStateActor provides comprehensive debug session summary upon deactivation"
        }
      ]
    },
    {
      "@id": "ex:Test_DecisionLogStateActor_DecisionLogging_HappyPath",
      "@type": "Test",
      "metadata": {
        "name": "Test_DecisionLogStateActor_DecisionLogging_HappyPath",
        "description": "Test decision logging functionality - DecisionLogStateActor should log and track decisions made during GAB workflow",
        "type": "MessageResponseTest",
        "priority": 2
      },
      "setup": "Set up DecisionLogStateActor with empty decision log",
      "teardown": "Reset DecisionLogStateActor state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:DecisionLogStateActor"
            },
            "payload": {
              "action": "logDecision",
              "decision": {
                "id": "mode_transition_001",
                "type": "mode_transition",
                "fromMode": "DiscussionMode",
                "toMode": "FormalizationMode",
                "reason": "All discussion satisfaction indicators met",
                "confidence": 0.95,
                "actor": "DiscussionActor1",
                "timestamp": "timestamp"
              }
            }
          }
        ]
      },
      "outputs": {
        "observedStateChanges": {
          "mode": "ex:TestResultReportingModeState",
          "stateChanges": {
            "decisionLog": [
              {
                "id": "mode_transition_001",
                "type": "mode_transition",
                "fromMode": "DiscussionMode",
                "toMode": "FormalizationMode",
                "reason": "All discussion satisfaction indicators met",
                "confidence": 0.95,
                "actor": "DiscussionActor1",
                "timestamp": "timestamp",
                "loggedAt": "timestamp"
              }
            ],
            "decisionCount": 1,
            "lastDecisionType": "mode_transition",
            "decisionsByType": {
              "mode_transition": 1
            }
          }
        },
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false,
          "decisionLogged": true
        }
      },
      "assertions": [
        {
          "type": "stateConsistency",
          "expected": "Decision properly logged with complete metadata"
        },
        {
          "type": "hasProperty",
          "expected": "Decision log includes id, type, reason, confidence, actor, and timestamps"
        },
        {
          "type": "satisfiesConstraint",
          "expected": "Decision count and categorization tracking maintained"
        },
        {
          "type": "actorBehavior",
          "expected": "DecisionLogStateActor comprehensively tracks all GAB workflow decisions"
        }
      ]
    },
    {
      "@id": "ex:Test_DecisionLogStateActor_DecisionRetrieval_HappyPath",
      "@type": "Test",
      "metadata": {
        "name": "Test_DecisionLogStateActor_DecisionRetrieval_HappyPath",
        "description": "Test decision retrieval functionality - DecisionLogStateActor should provide access to logged decisions for analysis",
        "type": "MessageResponseTest",
        "priority": 2
      },
      "setup": "Set up DecisionLogStateActor with populated decision log",
      "teardown": "Reset DecisionLogStateActor state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:DecisionLogStateActor"
            },
            "payload": {
              "action": "retrieveDecisions",
              "filter": {
                "type": "mode_transition",
                "actor": "DiscussionActor1"
              }
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:DecisionLogStateActor",
              "to": "user"
            },
            "payload": {
              "action": "decisionsRetrieved",
              "filter": {
                "type": "mode_transition",
                "actor": "DiscussionActor1"
              },
              "results": [
                {
                  "id": "mode_transition_001",
                  "type": "mode_transition",
                  "fromMode": "DiscussionMode",
                  "toMode": "FormalizationMode",
                  "reason": "All discussion satisfaction indicators met",
                  "confidence": 0.95,
                  "timestamp": "timestamp"
                }
              ],
              "resultCount": 1,
              "totalMatching": 1
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false,
          "decisionsRetrieved": true
        }
      },
      "assertions": [
        {
          "type": "satisfiesConstraint",
          "expected": "Supports filtering by decision type and actor"
        },
        {
          "type": "hasProperty",
          "expected": "Returns complete decision records with all metadata"
        },
        {
          "type": "contains",
          "expected": "Provides result count and filtering summary"
        },
        {
          "type": "actorBehavior",
          "expected": "DecisionLogStateActor provides comprehensive decision history access and filtering"
        }
      ]
    },
    {
      "@id": "ex:Test_DecisionLogStateActor_SessionConsistency_HappyPath",
      "@type": "Test",
      "metadata": {
        "name": "Test_DecisionLogStateActor_SessionConsistency_HappyPath",
        "description": "Test session consistency tracking - DecisionLogStateActor should maintain decision history across sessions for consistency",
        "type": "MessageResponseTest",
        "priority": 2
      },
      "setup": "Set up DecisionLogStateActor with cross-session decision history",
      "teardown": "Reset DecisionLogStateActor state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:DecisionLogStateActor"
            },
            "payload": {
              "action": "checkSessionConsistency",
              "currentSession": "session_2024_001",
              "previousDecisions": [
                {
                  "session": "session_2023_050",
                  "actor": "ClarificationActor1",
                  "decision": "confidence_threshold_0.8"
                }
              ]
            }
          }
        ]
      },
      "outputs": {
        "observedStateChanges": {
          "mode": "ex:TestResultReportingModeState",
          "stateChanges": {
            "sessionConsistency": {
              "currentSession": "session_2024_001",
              "previousSessions": ["session_2023_050"],
              "consistentDecisions": [
                {
                  "actor": "ClarificationActor1",
                  "decision": "confidence_threshold_0.8",
                  "consistencyStatus": "maintained"
                }
              ],
              "consistencyScore": 1.0
            },
            "crossSessionHistory": [
              {
                "session": "session_2023_050",
                "actor": "ClarificationActor1",
                "decision": "confidence_threshold_0.8",
                "carriedForward": true
              }
            ]
          }
        },
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false,
          "consistencyChecked": true
        }
      },
      "assertions": [
        {
          "type": "stateConsistency",
          "expected": "Session consistency properly tracked and maintained"
        },
        {
          "type": "hasProperty",
          "expected": "Cross-session decision history preserved and accessible"
        },
        {
          "type": "satisfiesConstraint",
          "expected": "Consistency score calculated and tracked (1.0 = fully consistent)"
        },
        {
          "type": "actorBehavior",
          "expected": "DecisionLogStateActor maintains session consistency and cross-session decision history"
        }
      ],
    {
      "@id": "ex:Test_DebugModeStateActor_StateRequest_HappyPath",
      "@type": "Test",
      "metadata": {
        "name": "Test_DebugModeStateActor_StateRequest_HappyPath",
        "description": "Test state request message handling - DebugModeStateActor should respond to state request messages with current debug mode status",
        "type": "MessageResponseTest",
        "priority": 2
      },
      "setup": "Set up DebugModeStateActor with debug mode OFF",
      "teardown": "Reset DebugModeStateActor state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:DebugModeStateActor"
            },
            "payload": {
              "action": "requestState",
              "requestType": "debugMode"
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:DebugModeStateActor",
              "to": "user"
            },
            "payload": {
              "responseType": "stateResponse",
              "debugMode": "OFF"
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false
        }
      },
      "assertions": [
        {
          "type": "messageFormat",
          "expected": "State response follows ex:StateMessageProtocol.stateResponseMessage format"
        },
        {
          "type": "contains",
          "expected": "Response contains debug mode status (ON or OFF)"
        },
        {
          "type": "actorBehavior",
          "expected": "DebugModeStateActor responds correctly to state request messages"
        }
      ]
    },
    {
      "@id": "ex:Test_DebugModeStateActor_StateRequest_InvalidRequest",
      "@type": "Test",
      "metadata": {
        "name": "Test_DebugModeStateActor_StateRequest_InvalidRequest",
        "description": "Test invalid state request format rejection - DebugModeStateActor should reject malformed state request messages",
        "type": "MessageResponseTest",
        "priority": 2
      },
      "setup": "Set up DebugModeStateActor",
      "teardown": "Reset DebugModeStateActor state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:DebugModeStateActor"
            },
            "payload": {
              "action": "requestState",
              "invalidField": "malformed"
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:DebugModeStateActor",
              "to": "user"
            },
            "payload": {
              "error": "State request error",
              "details": "Malformed state request message"
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": false,
          "messageRejected": true
        }
      },
      "assertions": [
        {
          "type": "excludes",
          "expected": "State should not be corrupted by invalid request"
        },
        {
          "type": "contains",
          "expected": "Error message explains validation failure"
        },
        {
          "type": "actorBehavior",
          "expected": "DebugModeStateActor handles invalid state requests gracefully"
        }
      ]
    },
    {
      "@id": "ex:Test_DebugModeStateActor_StateUpdate_Boundary",
      "@type": "Test",
      "metadata": {
        "name": "Test_DebugModeStateActor_StateUpdate_Boundary",
        "description": "Test boundary values for debug mode state updates - DebugModeStateActor should handle case-insensitive 'ON'/'OFF' values correctly",
        "type": "MessageResponseTest",
        "priority": 2
      },
      "setup": "Set up DebugModeStateActor with debug mode OFF",
      "teardown": "Reset DebugModeStateActor state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:DebugModeStateActor"
            },
            "payload": {
              "action": "updateState",
              "debugMode": "on"
            }
          },
          {
            "routingGraph": {
              "to": "ex:DebugModeStateActor"
            },
            "payload": {
              "action": "updateState",
              "debugMode": "OFF"
            }
          }
        ],
        "messageSequence": [0, 1]
      },
      "outputs": {
        "observedStateChanges": {
          "mode": "ex:TestResultReportingModeState",
          "stateAfter": {
            "debugMode": "OFF"
          }
        },
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false
        }
      },
      "assertions": [
        {
          "type": "stateConsistency",
          "expected": "State accepts case-insensitive values and normalizes to uppercase"
        },
        {
          "type": "satisfiesConstraint",
          "expected": "Both 'on' and 'OFF' are accepted and normalized correctly"
        },
        {
          "type": "actorBehavior",
          "expected": "DebugModeStateActor handles case-insensitive boundary values correctly"
        }
      ]
    },
    {
      "@id": "ex:Test_DebugModeStateActor_StateUpdate_InvalidInput",
      "@type": "Test",
      "metadata": {
        "name": "Test_DebugModeStateActor_StateUpdate_InvalidInput",
        "description": "Test rejection of invalid debug mode values - DebugModeStateActor should reject values that are not 'ON' or 'OFF'",
        "type": "MessageResponseTest",
        "priority": 2
      },
      "setup": "Set up DebugModeStateActor with initial valid state",
      "teardown": "Reset DebugModeStateActor state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:DebugModeStateActor"
            },
            "payload": {
              "action": "updateState",
              "debugMode": "enabled"
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:DebugModeStateActor",
              "to": "user"
            },
            "payload": {
              "error": "State update error: Debug mode must be ON or OFF",
              "details": "Invalid debug mode value: enabled"
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": false,
          "messageRejected": true
        }
      },
      "assertions": [
        {
          "type": "excludes",
          "expected": "State should not be corrupted by invalid input values"
        },
        {
          "type": "contains",
          "expected": "Error message explains validation failure: 'State update error: Debug mode must be ON or OFF'"
        },
        {
          "type": "satisfiesConstraint",
          "expected": "Invalid input does not corrupt existing valid state"
        },
        {
          "type": "actorBehavior",
          "expected": "DebugModeStateActor rejects invalid debug mode values with clear error"
        }
      ]
    },
    {
      "@id": "ex:Test_DebugModeStateActor_StateUpdate_StateError",
      "@type": "Test",
      "metadata": {
        "name": "Test_DebugModeStateActor_StateUpdate_StateError",
        "description": "Test handling of corrupted state conditions - DebugModeStateActor should handle null state values and invalid state transitions gracefully",
        "type": "MessageResponseTest",
        "priority": 2
      },
      "setup": "Corrupt DebugModeStateActor state with null values",
      "teardown": "Reset DebugModeStateActor state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:DebugModeStateActor"
            },
            "payload": {
              "action": "updateState",
              "debugMode": "ON"
            }
          }
        ]
      },
      "outputs": {
        "observedStateChanges": {
          "mode": "ex:TestResultReportingModeState",
          "stateChanges": {
            "debugMode": "ON"
          }
        },
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false
        }
      },
      "assertions": [
        {
          "type": "stateConsistency",
          "expected": "Actor recovers from corrupted state and updates correctly"
        },
        {
          "type": "satisfiesConstraint",
          "expected": "State corruption does not prevent valid operations"
        },
        {
          "type": "excludes",
          "expected": "No crashes or undefined behavior when handling corrupted state"
        },
        {
          "type": "actorBehavior",
          "expected": "DebugModeStateActor handles state errors gracefully"
        }
      ]
    },
    {
      "@id": "ex:Test_DebugModeStateActor_UserCommandParsing_HappyPath",
      "@type": "Test",
      "metadata": {
        "name": "Test_DebugModeStateActor_UserCommandParsing_HappyPath",
        "description": "Test parsing of user commands 'debug on' and 'debug off' - DebugModeStateActor should parse user commands and update state accordingly",
        "type": "MessageResponseTest",
        "priority": 2
      },
      "setup": "Set up DebugModeStateActor with debug mode OFF",
      "teardown": "Reset DebugModeStateActor state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "from": "user",
              "to": "ex:DebugModeStateActor"
            },
            "payload": {
              "command": "debug on",
              "source": "user"
            }
          }
        ]
      },
      "outputs": {
        "observedStateChanges": {
          "mode": "ex:TestResultReportingModeState",
          "stateChanges": {
            "debugMode": "ON"
          }
        },
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false
        }
      },
      "assertions": [
        {
          "type": "stateConsistency",
          "expected": "User command 'debug on' properly parsed and state updated"
        },
        {
          "type": "satisfiesConstraint",
          "expected": "Command parsing extracts 'on' and normalizes to 'ON'"
        },
        {
          "type": "actorBehavior",
          "expected": "DebugModeStateActor correctly parses user commands and updates state"
        }
      ]
    },
    {
      "@id": "ex:Test_DebugModeStateActor_UserCommandParsing_InvalidCommand",
      "@type": "Test",
      "metadata": {
        "name": "Test_DebugModeStateActor_UserCommandParsing_InvalidCommand",
        "description": "Test rejection of invalid user commands - DebugModeStateActor should reject commands that are not 'debug on' or 'debug off'",
        "type": "MessageResponseTest",
        "priority": 2
      },
      "setup": "Set up DebugModeStateActor",
      "teardown": "Reset DebugModeStateActor state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "from": "user",
              "to": "ex:DebugModeStateActor"
            },
            "payload": {
              "command": "debug enable",
              "source": "user"
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:DebugModeStateActor",
              "to": "user"
            },
            "payload": {
              "error": "Invalid command",
              "details": "Debug mode commands must be 'debug on' or 'debug off'"
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": false,
          "messageRejected": true
        }
      },
      "assertions": [
        {
          "type": "excludes",
          "expected": "State should not be corrupted by invalid command"
        },
        {
          "type": "contains",
          "expected": "Error message explains invalid command"
        },
        {
          "type": "actorBehavior",
          "expected": "DebugModeStateActor rejects invalid user commands gracefully"
        }
      ]
    },
    {
      "@id": "ex:Test_DebugModeStateActor_StateUpdate_EdgeCase",
      "@type": "Test",
      "metadata": {
        "name": "Test_DebugModeStateActor_StateUpdate_EdgeCase",
        "description": "Test rapid toggling of debug mode - DebugModeStateActor should handle rapid successive state updates and maintain state consistency",
        "type": "MessageResponseTest",
        "priority": 2
      },
      "setup": "Set up DebugModeStateActor with initial state",
      "teardown": "Reset DebugModeStateActor state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:DebugModeStateActor"
            },
            "payload": {
              "action": "updateState",
              "debugMode": "ON"
            }
          },
          {
            "routingGraph": {
              "to": "ex:DebugModeStateActor"
            },
            "payload": {
              "action": "updateState",
              "debugMode": "OFF"
            }
          },
          {
            "routingGraph": {
              "to": "ex:DebugModeStateActor"
            },
            "payload": {
              "action": "updateState",
              "debugMode": "ON"
            }
          }
        ],
        "messageSequence": [0, 1, 2]
      },
      "outputs": {
        "observedStateChanges": {
          "mode": "ex:TestResultReportingModeState",
          "stateAfter": {
            "debugMode": "ON"
          }
        },
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false
        }
      },
      "assertions": [
        {
          "type": "followsSequence",
          "expected": ["First update to ON processed", "Second update to OFF processed", "Third update to ON processed", "Final state reflects most recent update"]
        },
        {
          "type": "stateConsistency",
          "expected": "Rapid successive updates maintain state consistency"
        },
        {
          "type": "satisfiesConstraint",
          "expected": "Each update is processed independently without interference"
        },
        {
          "type": "actorBehavior",
          "expected": "DebugModeStateActor handles rapid updates correctly"
        }
      ]
    },
    {
      "@id": "ex:Test_DecisionLogStateActor_StateRequest_HappyPath",
      "@type": "Test",
      "metadata": {
        "name": "Test_DecisionLogStateActor_StateRequest_HappyPath",
        "description": "Test state request message handling - DecisionLogStateActor should respond to state request messages with current decision log state",
        "type": "MessageResponseTest",
        "priority": 2
      },
      "setup": "Set up DecisionLogStateActor with decisionCount=5, buildLogInitialized=true",
      "teardown": "Reset DecisionLogStateActor state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:DecisionLogStateActor"
            },
            "payload": {
              "action": "requestState",
              "requestType": "decisionLog"
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:DecisionLogStateActor",
              "to": "user"
            },
            "payload": {
              "responseType": "stateResponse",
              "decisionCount": 5,
              "buildLogInitialized": true,
              "buildLogFilename": "product/product-build-log.md"
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false
        }
      },
      "assertions": [
        {
          "type": "messageFormat",
          "expected": "State response follows ex:StateMessageProtocol.stateResponseMessage format"
        },
        {
          "type": "hasProperty",
          "expected": "Response contains decisionCount, buildLogInitialized, and buildLogFilename"
        },
        {
          "type": "actorBehavior",
          "expected": "DecisionLogStateActor responds correctly to state request messages"
        }
      ]
    },
    {
      "@id": "ex:Test_DecisionLogStateActor_BuildLogFilenameInitialization_HappyPath",
      "@type": "Test",
      "metadata": {
        "name": "Test_DecisionLogStateActor_BuildLogFilenameInitialization_HappyPath",
        "description": "Test build log filename initialization when decisionCount transitions from 0 to 1 - DecisionLogStateActor should request productName and initialize buildLogFilename",
        "type": "MessageResponseTest",
        "priority": 2
      },
      "setup": "Set up DecisionLogStateActor with decisionCount=0, ProductNameStateActor with productName='test-product'",
      "teardown": "Reset DecisionLogStateActor and ProductNameStateActor state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:DecisionLogStateActor"
            },
            "payload": {
              "action": "updateState",
              "decisionCount": 1
            }
          }
        ]
      },
      "outputs": {
        "observedStateChanges": {
          "mode": "ex:TestResultReportingModeState",
          "stateChanges": {
            "decisionCount": 1,
            "buildLogInitialized": true,
            "buildLogFilename": "test-product/test-product-build-log.md"
          }
        },
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false
        }
      },
      "assertions": [
        {
          "type": "stateConsistency",
          "expected": "Build log filename initialized when decisionCount transitions from 0 to 1"
        },
        {
          "type": "satisfiesConstraint",
          "expected": "Filename format is '{productName}/{productName}-build-log.md'"
        },
        {
          "type": "hasProperty",
          "expected": "buildLogInitialized set to true after initialization"
        },
        {
          "type": "actorBehavior",
          "expected": "DecisionLogStateActor properly initializes build log filename on first decision"
        }
      ]
    },
    {
      "@id": "ex:Test_DecisionLogStateActor_BuildLogFilenameInitialization_NoProductName",
      "@type": "Test",
      "metadata": {
        "name": "Test_DecisionLogStateActor_BuildLogFilenameInitialization_NoProductName",
        "description": "Test fallback to default filename when productName is null - DecisionLogStateActor should use 'product/product-build-log.md' when productName is not set",
        "type": "MessageResponseTest",
        "priority": 2
      },
      "setup": "Set up DecisionLogStateActor with decisionCount=0, ProductNameStateActor with productName=null",
      "teardown": "Reset DecisionLogStateActor and ProductNameStateActor state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:DecisionLogStateActor"
            },
            "payload": {
              "action": "updateState",
              "decisionCount": 1
            }
          }
        ]
      },
      "outputs": {
        "observedStateChanges": {
          "mode": "ex:TestResultReportingModeState",
          "stateChanges": {
            "decisionCount": 1,
            "buildLogInitialized": true,
            "buildLogFilename": "product/product-build-log.md"
          }
        },
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false
        }
      },
      "assertions": [
        {
          "type": "stateConsistency",
          "expected": "Fallback filename used when productName is null"
        },
        {
          "type": "satisfiesConstraint",
          "expected": "Filename defaults to 'product/product-build-log.md' when productName not available"
        },
        {
          "type": "actorBehavior",
          "expected": "DecisionLogStateActor handles missing productName gracefully with fallback"
        }
      ]
    },
    {
      "@id": "ex:Test_DecisionLogStateActor_BuildLogFilenameRecalculation_HappyPath",
      "@type": "Test",
      "metadata": {
        "name": "Test_DecisionLogStateActor_BuildLogFilenameRecalculation_HappyPath",
        "description": "Test filename recalculation when productName is set after initialization - DecisionLogStateActor should recalculate buildLogFilename on next state update",
        "type": "MessageResponseTest",
        "priority": 2
      },
      "setup": "Set up DecisionLogStateActor with decisionCount=1, buildLogFilename='product/product-build-log.md', ProductNameStateActor with productName='new-product'",
      "teardown": "Reset DecisionLogStateActor and ProductNameStateActor state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:DecisionLogStateActor"
            },
            "payload": {
              "action": "updateState",
              "decisionCount": 2
            }
          }
        ]
      },
      "outputs": {
        "observedStateChanges": {
          "mode": "ex:TestResultReportingModeState",
          "stateChanges": {
            "decisionCount": 2,
            "buildLogFilename": "new-product/new-product-build-log.md"
          }
        },
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false
        }
      },
      "assertions": [
        {
          "type": "stateConsistency",
          "expected": "Filename recalculated when productName becomes available after initialization"
        },
        {
          "type": "satisfiesConstraint",
          "expected": "New filename format uses updated productName"
        },
        {
          "type": "actorBehavior",
          "expected": "DecisionLogStateActor properly recalculates filename when productName is set later"
        }
      ]
    },
    {
      "@id": "ex:Test_DecisionLogStateActor_DecisionCountValidation_Boundary",
      "@type": "Test",
      "metadata": {
        "name": "Test_DecisionLogStateActor_DecisionCountValidation_Boundary",
        "description": "Test boundary values for decisionCount validation - DecisionLogStateActor should accept 0 and reject negative values",
        "type": "MessageResponseTest",
        "priority": 2
      },
      "setup": "Set up DecisionLogStateActor with decisionCount=0",
      "teardown": "Reset DecisionLogStateActor state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:DecisionLogStateActor"
            },
            "payload": {
              "action": "updateState",
              "decisionCount": 0
            }
          },
          {
            "routingGraph": {
              "to": "ex:DecisionLogStateActor"
            },
            "payload": {
              "action": "updateState",
              "decisionCount": -1
            }
          }
        ],
        "messageSequence": [0, 1]
      },
      "outputs": {
        "observedStateChanges": {
          "mode": "ex:TestResultReportingModeState",
          "stateChanges": {
            "decisionCount": 0
          }
        },
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:DecisionLogStateActor",
              "to": "user"
            },
            "payload": {
              "error": "State update error",
              "details": "decisionCount must be non-negative integer"
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": true
        }
      },
      "assertions": [
        {
          "type": "stateConsistency",
          "expected": "State accepts boundary value 0 without corruption"
        },
        {
          "type": "excludes",
          "expected": "Negative decisionCount values are rejected"
        },
        {
          "type": "contains",
          "expected": "Error message explains validation failure for negative values"
        },
        {
          "type": "actorBehavior",
          "expected": "DecisionLogStateActor correctly validates decisionCount boundary values"
        }
      ]
    },
    {
      "@id": "ex:Test_DecisionLogStateActor_DecisionCountValidation_InvalidInput",
      "@type": "Test",
      "metadata": {
        "name": "Test_DecisionLogStateActor_DecisionCountValidation_InvalidInput",
        "description": "Test rejection of non-integer decisionCount values - DecisionLogStateActor should reject non-numeric and non-integer values",
        "type": "MessageResponseTest",
        "priority": 2
      },
      "setup": "Set up DecisionLogStateActor with initial valid state",
      "teardown": "Reset DecisionLogStateActor state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:DecisionLogStateActor"
            },
            "payload": {
              "action": "updateState",
              "decisionCount": "not_a_number"
            }
          }
        ]
      },
      "outputs": {
        "observedMessages": [
          {
            "routingGraph": {
              "from": "ex:DecisionLogStateActor",
              "to": "user"
            },
            "payload": {
              "error": "State update error",
              "details": "decisionCount must be non-negative integer"
            }
          }
        ],
        "observedBehavior": {
          "messageAccepted": false,
          "messageRejected": true
        }
      },
      "assertions": [
        {
          "type": "excludes",
          "expected": "State should not be corrupted by invalid input values"
        },
        {
          "type": "contains",
          "expected": "Error message explains validation failure"
        },
        {
          "type": "satisfiesConstraint",
          "expected": "Invalid input does not corrupt existing valid state"
        },
        {
          "type": "actorBehavior",
          "expected": "DecisionLogStateActor rejects invalid decisionCount values with clear error"
        }
      ]
    },
    {
      "@id": "ex:Test_DecisionLogStateActor_StateUpdate_StateError",
      "@type": "Test",
      "metadata": {
        "name": "Test_DecisionLogStateActor_StateUpdate_StateError",
        "description": "Test handling of corrupted state conditions - DecisionLogStateActor should handle null state values and invalid state transitions gracefully",
        "type": "MessageResponseTest",
        "priority": 2
      },
      "setup": "Corrupt DecisionLogStateActor state with null values",
      "teardown": "Reset DecisionLogStateActor state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:DecisionLogStateActor"
            },
            "payload": {
              "action": "updateState",
              "decisionCount": 3
            }
          }
        ]
      },
      "outputs": {
        "observedStateChanges": {
          "mode": "ex:TestResultReportingModeState",
          "stateChanges": {
            "decisionCount": 3
          }
        },
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false
        }
      },
      "assertions": [
        {
          "type": "stateConsistency",
          "expected": "Actor recovers from corrupted state and updates correctly"
        },
        {
          "type": "satisfiesConstraint",
          "expected": "State corruption does not prevent valid operations"
        },
        {
          "type": "excludes",
          "expected": "No crashes or undefined behavior when handling corrupted state"
        },
        {
          "type": "actorBehavior",
          "expected": "DecisionLogStateActor handles state errors gracefully"
        }
      ]
    },
    {
      "@id": "ex:Test_DecisionLogStateActor_StateUpdate_EdgeCase",
      "@type": "Test",
      "metadata": {
        "name": "Test_DecisionLogStateActor_StateUpdate_EdgeCase",
        "description": "Test rapid decision logging and state consistency - DecisionLogStateActor should handle rapid successive decision count updates and maintain state consistency",
        "type": "MessageResponseTest",
        "priority": 2
      },
      "setup": "Set up DecisionLogStateActor with decisionCount=0",
      "teardown": "Reset DecisionLogStateActor state",
      "inputs": {
        "messages": [
          {
            "routingGraph": {
              "to": "ex:DecisionLogStateActor"
            },
            "payload": {
              "action": "updateState",
              "decisionCount": 1
            }
          },
          {
            "routingGraph": {
              "to": "ex:DecisionLogStateActor"
            },
            "payload": {
              "action": "updateState",
              "decisionCount": 2
            }
          },
          {
            "routingGraph": {
              "to": "ex:DecisionLogStateActor"
            },
            "payload": {
              "action": "updateState",
              "decisionCount": 3
            }
          }
        ],
        "messageSequence": [0, 1, 2]
      },
      "outputs": {
        "observedStateChanges": {
          "mode": "ex:TestResultReportingModeState",
          "stateAfter": {
            "decisionCount": 3
          }
        },
        "observedBehavior": {
          "messageAccepted": true,
          "messageRejected": false
        }
      },
      "assertions": [
        {
          "type": "followsSequence",
          "expected": ["First update to 1 processed", "Second update to 2 processed", "Third update to 3 processed", "Final state reflects most recent update"]
        },
        {
          "type": "stateConsistency",
          "expected": "Rapid successive updates maintain state consistency"
        },
        {
          "type": "satisfiesConstraint",
          "expected": "Each update is processed independently without interference"
        },
        {
          "type": "actorBehavior",
          "expected": "DecisionLogStateActor handles rapid updates correctly"
        }
      ]
    }
  ]
}